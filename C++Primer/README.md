# C++ Primer

# 开始
## 认识输入输出
- iostream
  - istream
  - ostream

### 标准输入输出对象
- cin
- cout
- cerr
- clog

``` c++
#include <iostream>

int main() {
  std::cout << "Enter two number" << std::endl;
  int v1 = 0, v2 = 0;
  std::cin >> v1 >> v2;
  std::cout << v1 + v2 << std::endl;
  return 0;
}

```

``` c++
#include <cstddef>
#include <iostream>

int main() {
  int sum = 0 , value = 0;
  while(std::cin >> value) {
    sum += value;
  }
  std::cout << sum << std::endl;
  return 0;
}

```

## 类简介
在c++中，我们通过定义一个类类定义自己的数据结构，一个类定义了一个类型，以及与其关联的一组操作

# 变量和基本类型
## 基本内置类型
bool类型的取值是true或false。

一个char的大小和一个机器字节一样，确保可以存放机器基本字符集中任意字符对应的数字值。wchar_t确保可以存放机器最大扩展字符集中的任意一个字符。

在整型类型大小方面，C++规定short ≤ int ≤ long ≤ long long（long long是C++11定义的类型）。

浮点型可表示单精度（single-precision）、双精度（double-precision）和扩展精度（extended-precision）值，分别对应float、double和long double类型。

除去布尔型和扩展字符型，其他整型可以分为带符号（signed）和无符号（unsigned）两种。带符号类型可以表示正数、负数和0，无符号类型只能表示大于等于0的数值。类型int、short、long和long long都是带符号的，在类型名前面添加unsigned可以得到对应的无符号类型，如unsigned int。

字符型分为char、signed char和unsigned char三种，但是表现形式只有带符号和无符号两种。类型char和signed char并不一样， char的具体形式由编译器（compiler）决定。

如何选择算数类型：
- 当明确知晓数值不可能为负时，应该使用无符号类型。
- 使用int执行整数运算，如果数值超过了int的表示范围，应该使用long long类型。
- 在算数表达式中不要使用char和bool类型。如果需要使用一个不大的整数，应该明确指定它的类型是signed char还是unsigned char。
- 执行浮点数运算时建议使用double类型。

### 类型转换
进行类型转换时，类型所能表示的值的范围决定了转换的过程。
- 把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。
- 把布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
- 把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分。
- 把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数（8比特大小的unsigned char能表示的数值总数是256）取模后的余数。
- 赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。

``` c++
// WRONG: u can never be less than 0; the condition will always succeed
for (unsigned u = 10; u >= 0; --u)
    std::cout << u << std::endl;

```

### 字面值常量（Literals）
以0开头的整数代表八进制（octal）数，以0x或0X开头的整数代表十六进制（hexadecimal）数。在C++14中，0b或0B开头的整数代表二进制（binary）数。

整型字面值具体的数据类型由它的值和符号决定。

C++14新增了单引号'形式的数字分隔符。数字分隔符不会影响数字的值，但可以通过分隔符将数字分组，使数值读写更容易。

### 标识符
C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。

### 名字的作用域
定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。
最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。

作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。

可以用作用域操作符::来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。

如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。

## 复合类型

### 引用
引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是变量名称。

定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。

引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。

声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。

引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。

### 指针
与引用类似，指针也实现了对其他对象的简介访问。
- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。
- 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

通过将声明符写成`*d`的形式来定义指针类型，其中d是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号`*`。

### 理解复合类型的声明


### const限定符


## 处理类型（Dealing with Types）


# 


# 



# 



