# 3.1 共享数据带来的问题

涉及到共享数据时，问题就可能是因为共享数据**修改**所导致。如果共享数据是只读的，那么操作不会影响到数据，更不会涉及对数据的修改，所以所有线程都会获得同样的数据。



并行中常见错误：*条件竞争*(race condition)

## 3.1.1 条件竞争

当你以写多线程程序为生，条件竞争就会成为你的梦魇

并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。大多数情况下，即使改变执行顺序，也是良性竞争，其结果可以接受。

例如，有两个线程同时向一个处理队列中添加任务，因为系统提供的不变量保持不变，所以谁先谁后都不会有什么影响。**当不变量(invariants)遭到破坏时，才会产生条件竞争，**



## 3.1.2 避免恶性条件竞争



1. 最简单的办法就是对数据结构采用某种保护机制，

确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。`C++`标准库提供很多类似的机制，下面会逐一介绍。

2. 另一个选择是对数据结构和不变量的设计进行修改，

修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的**无锁编程**。不过，这种方式很**难得到正确的结果**。如果到这个级别，无论是内存模型上的细微差异，还是线程访问数据的能力，都会让工作量变的很大。

3. 另一种处理条件竞争的方式是，使用事务的方式去处理数据结构的更新(这里的”处理”就如同对数据库进行更新一样)。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”(software transactional memory (STM))。理论研究中，这是一个很热门的研究领域。这个概念将不会在本书中再进行介绍，因为在`C++`中没有对STM进行直接支持

保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量。