**协程是啥**
首先我们得知道协程是啥？协程其实可以认为是比线程更小的执行单元。为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机，我们可以把一个协程 切换到 另一个协程。只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。



**协程和线程差异**
那么这个过程看起来比线程差不多哇。其实不然 线程切换从系统层面远不止 保存和恢复 CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。



**协程的问题**
但是协程有一个问题，就是系统并不感知，所以操作系统不会帮你做切换。那么谁来帮你做切换？让需要执行的协程更多的获得CPU时间才是问题的关键。

**笔者知道协程的实现相关的**
目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，也就是每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出CPU的API之类，触发下一次调度。对的没错就是类似于 **领导人**模式

**那么这个实现有没有问题？**
其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。这是一个问题，假设业务开发的人员并不懂这个原理的话就可能会出现问题。

**最后讲讲协程的好处**
在IO密集型的程序中由于IO操作远远小于CPU的操作，所以往往需要CPU去等IO操作。同步IO下系统需要切换线程，让操作系统可以再IO过程中执行其他的东西。这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。

所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。但是这样的坏处也是很大的，主要的坏处就是操作被   “分片”  了，代码写的不是 “一气呵成” 这种。 而是每次来段数据就要判断  数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。这样代码的可读性很低，其实也不符合人类的习惯。 

 但是协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。协程通过这种对异步IO的封装 既保留了性能也保证了代码的 容易编写和可读性。在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处。



#### 一、历史

早期的Unix时代崇尚同步编程，当时设计的时候也没多想，管他什么性能不性能，先做出来再说。所以最开始人是开多进程（process）再用管子（pipe）连接起来的；多直观啊，我把东西推进管子里，你走你那头接一下。

不知道哪天人注意到开个千儿八百个进程机器就卡死了，这怎么行，所以我们只搞一个进程，里面有一坨打开的网络连接和文件，用select这个系统调用对io事件同时进行监听，谁先来我就处理谁。然而发现性能也不好，没什么卵用。

人们在这两条路上都想办法提升性能。进程这边人们又搞了多线程，结果还是不够。多线程还是吃内核资源，抗不住。

Linux忍不住了，搞出个epoll（不过我不知道和freeBSD的kqueue哪个在前）系统调用，就是红黑树改良版的select。这下子人开心了，真他妈快啊，开千儿八百个连接小意思，同时进行事件监听，判断连接的的id和事件的类型，再打（dispatch）到不同的回调函数里。

不知是不是市场原因，正巧这时候互联网开始火了，性能越好赚钱越多嘛，所以肯定来这套高效的接口，管他好不好用呢，反正俺们吃苦耐劳，外加抖M，才不怕手动维护状态。你多线程开太多最后不也是要手动维护状态。

不熟悉操作系统的开发人员们只知道有什么用什么，也没去多想怎么优化多线程。现在多线程优化出来了，叫协程，调度器有的有（比如go的用户态调度器）, 有的没有（比如yield），取决于怎么用。其内存开销仍然比异步回调要大（一个协程一个栈，而异步回调的话一个event loop一共就一个栈），但是现在内存也是便宜了，不算是瓶颈。人最关注的是“千万不能堵着（block）”，要千方百计让CPU转起来，这样concurrency才能上去。而到处乱开协程（因为比线程便宜啊）就能达到这个效果，开十万个协程内存也没爆炸，跑上24个就能把CPU打满。所以异步回调的这个优势已经没了。



### 二、正文



首先去**刷汇编的寄存器和远跳指令**，搞清楚协程切换不过就是保存寄存器+跳转到另一个函数的半中间。在此之上可以构建个调度器，也可以不构建。刷TAOCP卷一的coroutine那一章也行。不弄懂协程的运作机制下盘不稳学起来也不踏实不是？

明白之后可以考虑**同步接口，异步接口和协程的关系**了。

假设你有10个文件，你想把10个文件拼接起来模拟成一个大文件。但是你内存又没那么大，那只好读一点让用户消耗一点了。所以你得写个filecat这样的adaptor。

如果所有接口都用同步，用户是爽了，仿佛直接在读一个文件；你实现得很蛋疼，每当用户问你要数据的时候，你得先检查我现在读到第几个文件了，读完了没有，后面还有没有别的文件了，要维护一坨状态。

如果所有接口都用异步，你是爽了，直接把用户的回调挨个传到不同的文件读写调用里去；用户则蛋疼了。要是用户想读三行，停一停去做些别的（比如处理下这三行），是很麻烦的，因为你这个adaptor往用户端塞数据塞得根本停不下来，用户有什么想法都得往回调函数里塞。“我现在读到第几行了？如果小于三行，就先送到处理头三行的函数里去；如果等于三行，就要拿一下处理好的三行并送去不知道什么地方，如果大于三行，再干点别的。。。”所以用户得手动维护这些状态。

你会发现无论是同步还是异步，都有这种“手动维护状态”的问题。要想让adaptor和用户都开心，解法自然是协程。**我现在就用代码来表示状态**，执行一行就是状态的转移。但是两头的状态要交替变化，这边做三行，轮到那边做了；那边做完了，又回到这边来，这跳来跳去的，就是协程了。



不是我说，因为异步用多了很熟悉就说方便好用，这是不太客观的说法。而协程方便是因为“**用代码来表示状态，而不是维护一坨数据结构来表示状态**”，则客观得多。

我注意到从事应用开发和网络服务开发的人员对于底层可能没那么熟悉，有时候不免走了弯路。kqueue/epoll这么个简单的东西，被开发者们搞出花来了，异步编程事件回调一套一套的，写书的也有，写库的也有（最近那个reactive也是）。自然术业有专攻，但是倘若稍微花些精力过一遍底层概念，学习/发明上层东西的时候会快很多，也少些痛苦。

至于趋势什么的，也就赶个时髦吧，这些枝叶伎俩学学也要不了几个小时。如果是担心要花很多精力学习某个“技术”，又怕学了没用，故有“是不是趋势啊”这一问，那多半是根基不牢，打打基础就行了。

我是写C++的，我发现我唯一用callback/closure/lambda的地方是我有个函数，但是我想把这个函数扣个洞，让用户来填这个洞。用得还真不算多。



