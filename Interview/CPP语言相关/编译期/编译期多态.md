面向对象和多态

在面向对象的开发里，最基本的一个特性就是“多态” ——用相同的代码得到不同结果。

shape 类为例

```c++

class shape {
public:
  …
  virtual void draw(const position&) = 0;
};
```

上面的类定义意味着所有的子类必须实现 draw 函数，所以可以认为 shape 是定义了一个接口（按 Java 的概念）。在面向对象的设计里，接口抽象了一些基本的行为，实现类里则去具体实现这些功能。当我们有着接口类的指针或引用时，我们实际可以唤起具体的实现类里的逻辑。比如，在一个绘图程序里，我们可以在用户选择一种形状时，把形状赋给一个 shape 的（智能）指针，在用户点击绘图区域时，执行 draw 操作。根据指针指向的形状不同，实际绘制出的可能是圆，可能是三角形，也可能是其他形状。

**但这种面向对象的方式，并不是唯一一种实现多态的方式**。在很多动态类型语言里，有所谓的“鸭子”类型

> 如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子。

在这样的语言里，你可以不需要继承来实现 circle、triangle 等类，然后可以直接在这个类型的变量上调用 draw 方法。如果这个类型的对象没有 draw 方法，你就会在执行到 draw() 语句的时候得到一个错误（或异常）。

鸭子类型使得开发者可以不使用继承体系来灵活地实现一些“约定”，尤其是使得混合不同来源、使用不同对象继承体系的代码成为可能。唯一的要求只是，这些不同的对象有“共通”的成员函数。这些成员函数应当有相同的名字和相同结构的参数（并不要求参数类型相同）。

听起来很抽象？我们来看一下 C++ 中的具体例子。

### 容器类的共性

容器类是有很多共性的。其中，一个最最普遍的共性就是，容器类都有 begin 和 end 成员函数——这使得通用地遍历一个容器成为可能。容器类不必继承一个共同的 Container 基类，而我们仍然可以写出通用的遍历容器的代码，如使用基于范围的循环。

大部分容器是有 size 成员函数的，在“泛型”编程中，我们同样可以取得一个容器的大小，而不要求容器继承一个叫 SizeableContainer 的基类。

很多容器具有 push_back 成员函数，可以在尾部插入数据。同样，我们不需要一个叫 BackPushableContainer 的基类。在这个例子里，push_back 函数的参数显然是都不一样的，但明显，所有的 push_back 函数都只接收一个参数。

我们可以清晰看到的是，虽然 C++ 的标准容器没有对象继承关系，但彼此之间有着很多的同构性。这些同构性很难用继承体系来表达，也完全不必要用继承来表达。C++ 的模板，已经足够表达这些鸭子类型。

当然，作为一种静态类型语言，C++ 是不会在运行时才报告“没找到 draw 方法”这类问题的。这类错误可以在编译时直接捕获，更精确地来说，是在模板实例化的过程中。

### “动态”多态和“静态”多态的对比

我前面描述了面向对象的“动态”多态，也描述了 C++ 里基于泛型编程的“静态”多态。需要看到的是，两者解决的实际上是不太一样的问题。“动态”多态解决的是运行时的行为变化——就如我前面提到的，选择了一个形状之后，再选择在某个地方绘制这个形状——这个是无法在编译时确定的。“静态”多态或者“泛型”——解决的是很不同的问题，让适用于不同类型的“同构”算法可以用同一套代码来实现，实际上强调的是对代码的复用。C++ 里提供了很多标准算法，都一样只作出了基本的约定，然后对任何满足约定的类型都可以工作。以排序为例，C++ 里的标准 sort 算法（以两参数的重载为例）只要求：

* 参数满足随机访问迭代器的要求。
* 迭代器指向的对象之间可以使用 < 来比较大小，满足严格弱序关系。
* 迭代器指向的对象可以被移动。

它的性能超出 C 的 qsort，因为编译器可以内联（inline）对象的比较操作；而在 C 里面比较只能通过一个额外的函数调用来实现。此外，C 的 qsort 函数要求数组指向的内容是可按比特复制的，C++ 的 sort 则要求迭代器指向的内容是可移动的，可适用于更广的情况。

C++ 里目前有大量这样的泛型算法。随便列举几个:

* sort：排序
* reverse：反转
* count：计数
* find：查找
* max：最大值
* min：最小值
* minmax：最小值和最大值
* next_permutation：下一个排列
* gcd：最大公约数
* lcm：最小公倍数

C++ 支持几种不同形式的多态？

c++的多态性分**专用多态**和**通用多态**，专用多态又分**重载多态**和**强制多态**，通用多态又分**包含多态**和**参数多态**。

重载多态：函数重载和操作符重载。
强制多态：使一个变量类型加以变化让其符合函数操作的要求。
如：double a = 1.0;
    int b = 2;
    double c = a + b;
此时b会强制转换成double再进行+操作。



包含多态：虚函数重构。
参数多态：课程里的函数模板。





为什么并非所有的语言都支持这些不同的多态方式？

排除设计缺陷的情况，语言支持哪些多态方式，基本上取决于语言本身在类型方面的特性。

以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。