### 虚函数与内联

内联函数通常可以提高代码执行速度，很多普通函数会根据情况进行内联化，**但虚函数无法利用内联化的优势**。

因为内联是在编译阶段编译器将调用内联函数的位置用内联函数体替代（内联展开），但**虚函数本质上是运行期行为**。在编译阶段，编译器无法知道某处的虚函数调用在真正执行的时候需要调用哪个具体的实现（即编译阶段无法确定其具体绑定），因此，编译阶段编译器不会对通过指针或引用调用的虚函数进行内联化。如果需要利用虚函数的动态绑定的设计优势，必须放弃内联带来的速度优势。

如果不使用虚函数，可以通过在抽象基类增加一个类型标识成员用于在运行时识别具体的派生类对象，在派生类对象构造时必须指定具体的类型。继承体系的使用者调用函数时不再需要一次间接地根据虚函数表查找虚函数指针的操作，但在调用前仍然需要使用switch语句对其类型进行识别。

因此虚函数的缺点可以认为只有两条，即虚函数表的空间开销以及无法利用内联函数的速度优势。由于每个含有虚函数的类在整个程序只有一个虚函数表，因此虚函数表引起的空间开销时非常小的。所以，可以认为虚函数引入的性能缺陷只是无法利用内联函数。
通常，非虚函数的常规设计假如需要增加一种新的派生类型，或者删除一种不再支持的派生类型，都必须修改继承体系所有使用者的所有与类型相关的函数调用代码。对于一个复杂的程序，某个继承体系的使用者会很多，每次对继承体系的派生类的修改都会波及使用者。因此，不使用虚函数的常规设计增加了代码的耦合度，模块化不强，导致项目的可扩展性、可维护性、代码可读性都会降低。面向对象编程的一个重要目的就是增加程序的可扩展性和可维护性，即当程序的业务逻辑发生改变时，对原有程序的修改非常方便，降低因为业务逻辑改变而对代码修改时出错的概率。
因此，在性能和其它特性的选择方面，需要开发人员根据实际情况进行进行权衡和取舍，如果性能检验确认性能瓶颈不是虚函数没有利用内联的优势引起，可以不必考虑虚函数对性能的影响。

