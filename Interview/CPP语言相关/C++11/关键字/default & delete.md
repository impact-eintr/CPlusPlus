C++ 里类的四大函数你一定知道吧，它们是构造函数、析构函数、拷贝构造函数、拷贝赋值函数。C++11 因为引入了右值（Rvalue）和转移（Move），又多出了两大函数：**转移构造函数和转移赋值函数**。所以，在现代 C++ 里，一个类总是会有六大基本函数：**三个构造、两个赋值、一个析构**。

* 默认构造函数
* 析构函数
* 拷贝构造函数
* 拷贝赋值函数
* 移动构造函数
* 移动赋值函数



生成这些特殊成员函数（或不生成）的规则比较复杂，每个特殊成员函数有几种不同的状态：

* 隐式声明还是用户声明
* 默认提供还是用户提供
* 正常状态还是删除状态



隐式声明的必然是默认提供的；默认提供的才可能被删除；用户提供的也必然是用户声明的。



如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：

* 没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除。
* 非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。
* 用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&) 或 Obj(const Obj&)；不是模板），编译器会隐式声明一个。
* 用户如果没有自己提供一个拷贝赋值函数（必须形如 Obj& operator=(Obj&) 或 Obj& operator=(const Obj&)；不是模板），编译器会隐式声明一个。
* 用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除。
* 用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。
* ……

我不鼓励你去死记硬背这些规则，而是希望你在项目和测试中体会其缘由。我认为这些规则还相当合理，虽然有略偏保守之嫌。尤其是关于移动构造和赋值：只要用户声明了另外的特殊成员函数中的任何一个，编译器就不默认提供了。不过嘛，缺省慢点总比缺省不安全要好……

我们这儿主要要说的是，我们可以改变缺省行为，在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。

还是举例子来说明一下。对于下面这样的类，编译器看到有用户提供的构造函数，就会不默认提供默认构造函数：

```c++

template <typename T>
class my_array {
public:
  my_array(size_t size);
  …
private:
  T*     data_{nullptr};
  size_t size_{0};
};
```

在没有默认初始化时，我们如果需要默认构造函数，就需要手工写一个，如：

```c++

  my_array()
    : data_(nullptr)
    , size_(0) {}
```

可有了默认初始化之后，这个构造函数显然就不必要了，所以我们现在可以写：

```c++

  my_array() = default;
```



但如果正常情况不需要复制行为、只是想防止其他开发人员误操作时，我们可以简单地在类的定义中加入：

```c++

class shape_wrapper {
  …
  shape_wrapper(
    const shape_wrapper&) = delete;
  shape_wrapper& operator=(
    const shape_wrapper&) = delete;
  …
};
```

在 C++11 之前，我们可能会用在 private 段里声明这些成员函数的方法，来达到相似的目的。但目前这个语法效果更好，可以产生更明确的错误信息。另外，你可以注意一下，用户声明成删除也是一种声明，因此编译器不会提供默认版本的移动构造和移动赋值函数。
