### C++98 的函数对象

函数对象（function object）[1] 自 C++98 开始就已经被标准化了。从概念上来说，函数对象是一个可以被当作函数来用的对象。它有时也会被叫做 functor.

下面的代码定义了一个简单的加 n 的函数对象类（根据一般的惯例，我们使用了 struct 关键字而不是 class 关键字）：

```c++
struct adder {
  adder(int n) : n_(n) {}
  int operator()(int x) const
  {
    return x + n_;
  }
private:
  int n_;
};
```

它看起来相当普通，唯一有点特别的地方就是定义了一个 operator()，这个运算符允许我们像调用函数一样使用小括号的语法。随后，我们可以定义一个实际的函数对象，

```c++
auto add_2 = adder(2); //C++11 形式
adder add_2(2);//C++98 形式
```

得到的结果 add_2 就可以当作一个函数来用了。你如果写下 add_2(5) 的话，就会得到结果 7。



C++98 里也定义了少数高阶函数：你可以传递一个函数对象过去，结果得到一个新的函数对象。最典型的也许是目前已经从 C++17 标准里移除的 bind1st 和 bind2nd 了（在< functional> 头文件中提供）：

### 函数的指针和引用

除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。不管是函数指针还是函数引用，你也都可以当成函数对象来用。

假设我们有下面的函数定义：

```c++
int add_2(int x)
{
  return x + 2;
};
```

如果我们有下面的模板声明：

```c++
template <typename T>
auto test1(T fn)
{
  return fn(2);
}

template <typename T>
auto test2(T& fn)
{
  return fn(2);
}

template <typename T>
auto test3(T* fn)
{
  return (*fn)(2);
}
```

当我们拿 add_2 去调用这三个函数模板时，fn 的类型将分别被推导为 `int (*)(int)、int (&)(int) 和 int (*)(int)`。不管我们得到的是指针还是引用，我们都可以直接拿它当普通的函数用。当然，在函数指针的情况下，我们直接写 *value 也可以。因而上面三个函数拿 add_2 作为实参调用的结果都是 4。

很多接收函数对象的地方，也可以接收函数的指针或引用。但在个别情况下，需要通过函数对象的类型来区分函数对象的时候，就不能使用函数指针或引用了——原型相同的函数，它们的类型也是相同的。

### bind 模板

我们上面提到了 bind1st 和 bind2nd 目前已经从 C++ 标准里移除。原因实际上有两个：

* 它的功能可以被 lambda 表达式替代

* 有了一个更强大的 bind 模板

原先我们只能把一个给定的参数绑定到第一个参数或第二个参数上，现在则可以非常自由地适配各种更复杂的情况！当然，bind 的参数数量，必须是第一个参数（函数对象）所需的参数数量加一。而 bind 的结果的参数数量则没有限制

你可能会问，它的功能是不是可以被 lambda 表达式替代呢。回答是“是”。对 bind 只需要稍微了解一下就好——在 C++14 之后的年代里，已经没有什么地方必须要使用 bind 了。

### function 模板

每一个 lambda 表达式都是一个单独的类型，所以只能使用 auto 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用 function 模板。

function 模板的参数就是函数的类型，一个函数对象放到 function 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。注意 function 对象的创建还是比较耗资源的，所以请你只在用 auto 等方法解决不了问题的时候使用这个模板。

下面是个简单的例子。

```c++

map<string, function<int(int, int)>>
  op_dict{
    {"+",
     [](int x, int y) {
       return x + y;
     }},
    {"-",
     [](int x, int y) {
       return x - y;
     }},
    {"*",
     [](int x, int y) {
       return x * y;
     }},
    {"/",
     [](int x, int y) {
       return x / y;
     }},
  };
```

这儿，由于要把**函数对象存到一个 map 里**(很多STL处理都是这样！)，我们必须使用 function 模板。随后，我们就可以用类似于 op_dict.at("+")(1, 6) 这样的方式来使用 function 对象。这种方式对表达式的解析处理可能会比较有用。