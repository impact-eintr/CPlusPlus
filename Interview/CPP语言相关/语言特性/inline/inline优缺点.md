
## 优点：

1. inline定义的内联函数，函数代码被放入符号表中，在使用时进行替换（内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度），效率很高。

2. 类的内联函数也是函数。编绎器在调用一个内联函数，首先会检查参数问题，保证调用正确，像对待真正函数一样，消除了隐患及局限性。内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 

3. inline可以作为类的成员函数。在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。

4. 内联函数在运行时可调试，而宏定义不可以。

## 缺点：


1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大（比如函数体内有循环），那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。这种情况编译器可能会自动把它作为非内联函数处理。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。





### 内联函数一般可以：

1. 加快程序的执行速度；

2. 可能减小可执行文件的大小；

3. 可能增加可执行文件的大小；

4. 可能降低执行速度。

1和3很好理解，在编译时期内联函数能将代码直接写入其被调用的地方，这样就减少了入栈出栈的时间消耗，但是如果调用内联函数的地方过多，**代码量也会随之增加，增加了可执行文件的大小。**

2为什么正确呢？是因为如果调用普通函数的话编译器可能会产生更多的代码来实现压、出寄存器的代码，对于简单的内联函数会这样。但如果优化器能顺序集成消除大量冗余代码的话，对大函数也同样适用。

4呢？**如果可执行文件过大，会频繁的出现内存的换入换出操作，会使执行速度下降。**
