### 请说一下C/C++ 中指针和引用的区别？
#### 定义：
1、引用：

C ++ 是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。

2、指针：

指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

#### 区别：
1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；

4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；

5. 可以有const指针，但是没有const引用；

6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

7. 指针可以有多级指针（**p），而引用至于一级；

8. 指针和引用使用++运算符的意义不一样；

9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。



###  指针与引用的区别

(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：int a=1;int *p=&a;int a=1;int &b=a;前面两句定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而后面两句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

(2)引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。

(3)可以有const指针，但是没有const引用；

(4)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

(5)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

(6)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

(7)”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；

(8)指针和引用的自增(++)运算意义不一样；

(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；

### C++中指针与引用可以只要一个吗？

1. 为什么有了引用还需要指针呢?
2. 为什么有了指针还需要引用呢?
问题1：这个比较简单，因为为了兼容C语言,必然要支持指针了。

问题2：一开始C+ +是没有引用的。比如说: this, 被定义为了指针，而不是引用。后来加入了引用的原因主要是为了支持运算符重载。假设C+ +里面没有引用，而只有指针，会有什么样的问题。如果用指针来运算符重载的话，就像:

ClassFun operator+( const ClassFun *, const ClassFun * )

使用的时候只能是&a + &b,这和我们通常的写法a + b不太一样,看上去不太习惯。还可以进一步假设，也可以就写成a + b,让编译器来根据operator+的类型来解释a和b的类型。如果operator +的参数是值，那就解释成值;如果是指针，就解释成地址。这和现在C+ +里面把名字解释成值或者引用是一个道理。这样做的后果是，指针和值不能重载了。

**引用带来的好处：**
用指针的使用经常犯得错：1，操作空指针.2，操作野指针.3，误操作改变了指针的值，而后还以为该指针正常。如果我们要正确的使用指针，我们不得不人为地保证这三个条件。而引用的提出就解决了这个问题。
引用区别于指针的特性是 ：1，不存在空引用（保证不操作空指针），2，必须初始化（保证不是野指针），3，一个引用永远指向他初始化的那个对象，一旦初始化就不能改变初始化的值（保证指针值不变）。**人为保证变为了编译器来保证，更加安全。**

**注意事项：**

用户自定义的类型最好用引用传参，这样可以避免不必要的构造函数和析构函数调用，但是对于像int,long,char一类的**内置类型，按值传参会比按引用传参更高效。**

