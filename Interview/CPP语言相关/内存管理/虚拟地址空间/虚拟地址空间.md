
### 以下代码在内核中的内存分配上发生了什么？

```c++
A* a = new A; 
 a->i = 10;
```

1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节（32位/64位）的空间（0x000m），分配给指针a。

2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。

3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。

4）a->i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a->i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。


```c++
#include <iostream>
using namespace std;

/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/

int g_var = 0; // g_var 在全局区（不知道是.data 段，还是由于初始化为0所以在.bss段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}


```

### C++的内存管理

**虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区(动态库也在这里)以及栈区六部分。**
![image](https://pic4.zhimg.com/80/v2-43106bc5762193388008334d4f6bf45b_1440w.jpg)

#### ==静态区域：==
（程序结束后静态变量资源由系统自动释放）
1. 代码段(text segment TXT): 包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量
(存放函数体的二进制代码)


2. 数据(data)段(初始化的数据段)：存储程序中已初始化的全局变量和静态变量(为数据分配空间，数据保存在目标文件中)

3. bss 段(Block Started by Symbol)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0.
(.bss段被用来存放那些没有初始化或者初始化为0的全局变量。bss段只占运行时的内存空间而不占文件空间。在程序运行的整个周期内，.bss段的数据一直存在)

一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。
![image](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470750551_BF3BB3BB445EFF96BEAE1410CE2CDA74)

text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。

bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。

data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。

数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。


可执行程序在运行时又多出两个区域：栈区和堆区。

#### ==动态区域：==
4. 堆区(heap)：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由`mm_struct` 结构体中的`start_brk`标识，结束地址由brk标识。

用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。
(一般由程序员分配释放， 若程序员不释放，在程序结束时，操作系统回收。)

5. 映射区(memory mapping segment): 存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）

6. 栈(stack)：使用栈空间存储函数的返回地址、参数、局部变量、返回值。从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。

由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。
(由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。)


7. 文字（只读）常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放




### 请你来说一说C++函数栈空间的最大值
参考回答：
默认是1M，不过可以调整
