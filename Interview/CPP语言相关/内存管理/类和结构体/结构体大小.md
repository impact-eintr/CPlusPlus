和数组不一样的是，结构体的大小不是所有成员大小简单的相加，**需要考虑到系统在存储结构体变量时的地址对齐问题**。

```c++
struct stu1
{
     int i;
     char c;
     int j;
}；
```

用sizeof求该结构体的大小，发现值为12。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？

 先介绍一个相关的概念——**偏移量**。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。

   然而，在实际中，**存储变量时地址要求对齐**，编译器在编译程序时会遵循两条原则：

   **（1）*结构体变量中成员的偏移量必须是成员大小的整数倍*（0被认为是任何数的整数倍）** 

   **（2）*结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数*。**

   上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。

再来看另外一个例子：

```c++
struct stu2
{
      int k;
      short t;
}；
```

成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。

​    由此可见，结构体类型需要考虑到字节对齐的情况，不同的顺序会影响结构体的大小。

```c++
struct stu3
{ 
       char c1; 
       int i;
       char c2;
}
struct stu4
{
       char c1;
       char c2;
       int i;
 }
```

 虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8。

 对于嵌套的结构体，需要将其展开。对结构体求sizeof时，上述两种原则变为：

​    **（1）*展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。***

​    **（2）*结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体*。**



```c++
struct stu5
{
      short i;  // 2
      // padding 2
      struct 
      {
           char c; // 1
           // padding 3
           int j; // 4
      } ss; 
      int k;	// 4
}
```

结构体stu5的成员ss.c的偏移量应该是4，而不是2。整个结构体大小应该是16( 2 + 2 + 1 + 3 +4 + 4)。



**没有成员的结构体占用的空间是多少个字节？**

   答案是：1个字节。

   这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。