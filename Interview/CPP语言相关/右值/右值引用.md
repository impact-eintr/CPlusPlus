### 右值引用

C++ 中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。

而在指C++11中，右值是由两个概念构成，==将亡值==和==纯右值==。纯右值是用于识别**临时变量**和一些**不跟对象关联**的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指**具有转移语义**的对象，比如返回右值引用T&&的函数返回值等。

右值引用是C++11中引入的新特性 , 右值引用(是一个左值)就是对一个右值进行引用的**类型**。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：


```
T && a=ReturnRvale();
```


假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用（a是左值），其值等于ReturnRvalue函数返回的临时变量的值。

右值引用可实现**转移语义**（Move Sementics）和**精确传递**（Perfect Forwarding）（完美转发）这两新特性，它的主要目的有两个方面：

* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
* 能够更简洁明确地定义泛型函数。



### 右值引用和左值引用的区别：

1. 右值引用必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

2. 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。


std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。





```c++
#include <iostream>
using namespace std;

void fun1(int& tmp) 
{ 
  cout << "fun1(int& tmp):" << tmp << endl; 
} 

void fun2(int&& tmp) 
{ 
  cout << "fun2(int&& tmp)" << tmp << endl; 
} 

int main() 
{ 
  int var = 11; 
  fun1(12); // error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'
  fun1(var);
  fun2(1); 
}

```



