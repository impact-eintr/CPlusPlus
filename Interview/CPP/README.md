# CPP面试大全——语言特性

<hr>

## 关键字
### static
#### static全局变量与普通全局变量
>  相同点

- 存储方式 普通全局变量和static全局变量都是静态存储方式(编译时分配内存)

> 不同点

- 作用域
  - 普通全局变量的作用于是整个源程序,当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的
  - 静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它
  - 由于静态全局变量的作用域限于一个源文件（编译模块）内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误
  例如在a.c中定义了static int a=10; 那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中。
- 初始化
  - 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值（比如整型的0）初始化它
  - 用static声明局部变量-------局部变量指在代码块 {} 内部定义的变量，只在代码块内部有效（作用域），用static声明局部变量时，则改变变量的存储方式（生命期），使变量成为静态的局部变量，即编译时就为变量分配内存，直到程序退出才释放存储单元。这样，使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用（作用域不变）
  - 修饰成员变量，在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
  
#### static修饰函数
- 修饰普通函数  修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static
> 如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可

- 修饰成员函数
  - 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名
  - 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）
  - 如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：`<类名>::<静态成员函数名>(<参数表>)`

> 返回函数中静态变量的地址会发生什么？

``` c++
#include <iostream>
using namespace std;

int * fun(int tmp){
    static int var = 10; // var会在编译阶段就分配在静态区
    var *= tmp;
    return &var;
}

int main() {
    cout << *fun(5) << endl;
    return 0;
}

/*
运行结果：
50
*/
```

说明：上述代码中在函数 fun 中定义了静态局部变量 var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。

#### static什么时候初始化
- 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存
- 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。\
  - 在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收
  - 而在C++中，**初始化时在执行相关代码时才会进行初始化**，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的

#### static在类中使用
**static静态成员变量**
1. 静态成员变脸是在类内进行声明， 在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现static关键字和private public protected访问规则 
2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，**包括派生类的对象**
3. **静态成员变脸可以作为成员函数的参数，而普通成员变量不可以**

``` c++
#include <iostream>
using namespace std;

class A
{
public:
    static int s_var;
    int var;
    void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数
    void fun2(int i = var);   //  error: invalid use of non-static data member 'A::var'
};
int main()
{
    return 0;
}
```
4. 静态数据成员的类型可以是所属类的类型，==而普通数据成员的类型只能是该类类型的指针或引用==。
```c++
#include <iostream>
using namespace std;

class A
{
public:
    static A s_var; // 正确，静态数据成员
    A var;          // error: field 'var' has incomplete type 'A'
    A *p;           // 正确，指针
    A &var1;        // 正确，引用
};

int main()
{
    return 0;
}
```

**static静态成员函数**
1. 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有this指针，必须通过类名才能访问。静态成员函数作为类作用域的全局函数。
2. 静态成员函数不能声明成虚函数、const函数和volatile函数

### volatile
#### volatile 的作用？是否具有原子性，对编译器有什么影响？
- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值），保证对特殊地址的稳定访问
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile 
- volatile不具有原子性。
- 注意
  - 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。
  - 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。
  - C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从==类传递到它的成员。==

#### 什么情况下一定要用 volatile， 能否和 const 一起使用？
使用 volatile 关键字的场景：
- 当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰
- 中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰
> 关键字volatile有什么含意?

答案：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

> volatile关键字

``` c++
volatile int i = 10;
```

- volatile关键字是一种类型修饰符，用它声明的类型变量可以被某些编译器位置的罂因素(操作系统、硬件、其他线程)更改。所以使用volatile告诉编译器不应该对这样的对象进行优化
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

> const, volatile区别

1. const含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”，是不可修改的只读变量。 volatile的含义是“请不要做自以为是的优化，这个值可能变掉的”，而并非“你可以修改这个值”。
2. 
- const只在编译期有用，在运行期无用
  - const在编译期保证在C的“源代码”里面，没有对其修饰的变量进行修改的地方（如有则报错，编译不通过），而运行期该变量的值是否被改变则不受const的限制。
- volatile在编译期和运行期都有用
  - 在编译期告诉编译器：请不要做自以为是的优化，这个变量的值可能会变掉；
  - 在运行期：每次用到该变量的值，都直接从内存中取该变量的值。
3. const, volatile同时修饰一个变量
- 合法性
  - `volatile`的含义并非是`non-const`,`volatile`和`const`不构成反义词，所以可以放在一起修饰一个变量
-  修饰同一个变量的含义
  - 表示一个变量在策划那个续编译器见不能被修改且不能被优化
  - 在程序运行期间，变量值可以修改，但每次用到该变量的值都要从内存中取用，以防止意外错误
### extern
> 请你来说一说extern“C”
- 被 extern 限定的函数或变量是 extern 类型的
- 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和链接的 extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。


> extern "C" 使用

``` c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

> extern C为什么需要？

基本解释：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

也就是说extern有两个作用。第一，当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的。

第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
### const
> 作用
- const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
- const 修饰函数参数，使得传递过来的函数参数的值不能改变。
- const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
> 在类中的用法

- `const` 成员变量

1. const 成员变量只能在类内声明定义，在构造函数初始化列表中初始化
2. cosnt 成员变量只能在某个对象的生命周期内是常量，对于整个类而言确实可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。

- `const` 成员函数

不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。 不能调用非常量成员函数，以防修改成员变量的值。

``` c++
#include <iostream>
using namespace std;

class A
{
public:
	int var;
	A(int tmp) : var(tmp) {}
	void c_fun(int tmp) const // const 成员函数
	{
		var = tmp; // error: assignment of member 'A::var' in read-only object. 在 const 成员函数中，不能修改任何类成员变量。		
		fun(tmp); // error: passing 'const A' as 'this' argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
	}

	void fun(int tmp)
	{
		var = tmp;
	}
};

int main()
{
    return 0;
}
```

> 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？
常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。
- 对于局部对象，常量存放在栈区
- 对于全局对象，常量存放在全局/静态存储区
- 对于字面值常量，常量存放在常量存储区

> const作用 "只读"

1. const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。

``` c++
TYPE const ValueName = value;

const TYPE ValueName = value;
```

2. 修饰指针
- 指向常量的指针 (pointer to const) const int*
- 自身是常量的指针  (const pointer) int* const

3. 修饰引用
- 指向常量的引用（reference to const）如果用于形参类型，即避免了拷贝，又避免了函数对值的修改； const int&
- 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰 no int& const

> const 使用

**实际上const和*的优先级相同，且是从右相左读的，即“右左法则”**

``` c++
比如int*p;//读作p为指针，指向int，所以p为指向int的指针

int*const p;//读作p为常量，是指针，指向int，所以p为指向int的常量指针， p不可修改

int const *p;//p为指针，指向常量，为int，所以p为指向int常量的指针， *p不可修改

int ** const p; //p为常量，指向指针，指针指向int，所以p为指向int型指针的常量指针，p不可修改

const int **p;//指向常量指针的指针

int const**p; //p为指针，指向指针，指针指向常量int，所以p为指针，指向一个指向int常量的指针， **p为int，不可修改

int * const *p ; //p为指针，指向常量，该常量为指针，指向int，所以p为指针，指向一个常量指针，*p为指针，不可修改

int ** const *p; //p为指针，指向常量，常量为指向指针的指针，p为指针，指向常量型指针的指针，*p为指向指针的指针，不可修改

int * const **p; //p为指针，指向一个指针1，指针1指向一个常量，常量为指向int的指针，即p为指针，指向一个指向常量指针的指针， **p为指向一个int的指针，不可修改

```

``` c++
// 类
class A
{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";      //字符串hello保存在栈区，可以通过greeting去修改
    const char * arr = "123"; //字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样
    char * brr = "123"; //字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值
    const char crr[] = "123";

//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
//确实，经过简单测试const char crr[]="123"; crr[1]='5';结果报错
//error: assignment of read-only location ‘crr[1]’
    
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明不能通过p2修改greeting，但是greeting在栈上可以通过其它方式修改，比如下标，和p1来修改）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变，即指针不能指向其它地址，但可以修改其中的值）
    //比如*(p2+1)='c'; 则报错assignment of read-only location ‘*(p2 + 1u)’
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

```

> 在函数中使用const
### inline


### mutable
mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。


## 深入理解左值和右值

``` c++
void fun(int &x) {
  // DO 
}

int main() {
  fun(10);
  return 0;
}
```

其中上述报错中的rvalue就是10，也就是说10就是rvalue，那么到底什么是rvalue，rvalue的意义是什么？这就是本文的目的，通过本文，让你彻底搞清楚什么C++下的值类别，以及如何区分左值、纯右值和将亡值。

C语言中的左值与CPL中的左值区别是，在C语言中lvalue是locator value的简写，因此lvalue对应了一块内存地址。

C++11之前，左值遵循了C语言的分类法，但与C不同的是，其将非左值表达式统称为右值，函数为左值，并添加了引用能绑定到左值但唯有const的引用能绑定到右值的规则。几种非左值的C表达式在C++中成为了左值表达式

自C++11开始，对值类别又进行了详细分类，在原有左值的基础上增加了纯右值和消亡值，并对以上三种类型通过是否具名(identity)和可移动(moveable)，又增加了glvalue和rvalue两种组合类型，在后面的内容中，会对这几种类型进行详细讲解。

### 表达式

C/C++代码是由标识符、表达式和语句以及一些必要的符号(大括号等)组成。

表达式由按照语言规则排列的运算符，常量和变量组成。一个表达式可以包含一个或多个操作数，零个或多个运算符来计算值。每个表达式都会产生一些值，该值将在赋值运算符的帮助下分配给变量。

在C/C++中，表达式有很多种，我们常见的有前后缀表达式、条件运算符表达式等。字面值(literal)和变量(variable)是最简单的表达式，函数的返回值也被认为是表达式。

表达式是可求值的，对表达式求值可得到一个结果，这个结果有两个属性:

- 类型。这个我们很常见，比如int、string、引用或者我们自定义的类。类型确定了表达式可以进行哪些操作。
- 值类别(在下节中会细讲)。

### 值类别
在上节中，我们提到表达式是可求值的，而值类别就是求值结果的属性之一。

在C++11之前，表达式的值分为左值和右值两种，其中右值就是我们理解中的字面值1、true、NULL等。

自C++11开始，表达式的值分为`左值(lvalue, left value)`、`将亡值(xvalue, expiring value)`、`纯右值(pvalue, pure ravlue)`以及两种混合类别`泛左值(glvalue, generalized lvalue)`和`右值(rvalue, right value)`五种。

这五种类别的分类基于表达式的两个特征：

- 具名(identity):可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址
- 可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式

结合上述两个特征，对五种表达式值类别进行重新定义：
- lvalue:具名且不可被移动
- xvaue:具名且可被移动
- prvalue:不具名且可被移动
- glvalue:具名，lvalue和xvalue都属于glvalue
- rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue

### 左值
左值(lvalue,left value)，顾名思义就是赋值符号左边的值。**准确来说，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。**

可以将左值看作是一个关联了名称的内存位置，允许程序的其他部分来访问它。在这里，我们将 "名称" 解释为任何可用于访问内存位置的表达式。所以，如果 arr 是一个数组，那么 arr[1] 和 *(arr+1) 都将被视为相同内存位置的“名称”。

左值具有以下特征：
- 可通过取地址运算符获取其地址
- 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数
- 可以用来初始化左值引用(后面有讲)

> 那么哪些都是左值呢?查了相关资料，做了些汇总，基本覆盖了所有的类型：

- 变量名、函数名以及数据成员名
- 返回左值引用的函数调用
- 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
- 解引用表达式*ptr
- 前置自增和自减表达式(++a, ++b)
- 成员访问（点）运算符的结果
- 由指针访问成员（ -> ）运算符的结果
- 下标运算符的结果([])
- 字符串字面值("abc")

``` c++
int a = 1; // a为左值
T& f();
f(); // 左值
++a; // 左值
--a; // 左值
int b = a; // a b 都是左值
struct S* ptr = &obj; // ptr 为左值
arr[1] = 2; // 左值
int *p = &a; // p为左值
*p = 10; // *p为左值
class MyClass{};
MyClass c; /// c为左值
"abc" // 左值
```

> **对于一个表达式，凡是对其取地址（&）操作可以成功的都是左值**

### 纯右值
在前面有提过，自C++11开始，纯右值(pvalue, pure ravlue)相当于之前的右值，那么什么是纯右值呢？

字面值或者函数返回的非引用都是纯右值。

> **以下表达式的值都是纯右值：**

- 字面值(字符串字面值除外)，例如1，'a', true等
- 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
- 后置自增和自减表达式(a++, a--)
- 算术表达式
- 逻辑表达式
- 比较表达式
- 取地址表达式
- lambda表达式

``` c++
nullptr;
true;
1;
int fun();
fun();

int a = 1;
int b = 2;
a + b;

a++;
b--;

a > b;
a && b;
```

> 纯右值特征：

- 等同于C++11之前的右值
- 不会是多态
- 不会是抽象类型或数组
- 不会是不完全类型

### 将亡值
将亡值(xvalue, expiring value)，顾名思义即将消亡的值，是C++11新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如**返回右值引用T&&的函数返回值**、**std::move的返回值**，或者**转换为T&&的类型转换函数的返回值**。

将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。（通过右值引用来续命）。

xvalue 只能通过两种方式来获得，这两种方式都涉及到将一个左值赋给(转化为)一个右值引用：
- 返回右值引用的函数的调用表达式,如 `static_cast<T&&>(t);` 该表达式得到一个 xvalue
- 转换为右值引用的转换函数的调用表达式，如：`std::move(t)`、`satic_cast<T&&>(t)`

``` c++
std::string fun() {
  std::string str;
  // ...
  
  return str;
}

std::string s = fun();
```

在函数fun()中，str是一个局部变量，并在函数结束时候被返回。

在C++11之前，s = fun();会调用拷贝构造函数，会将整个str复制一份，然后把str销毁。如果str特别大的话，会造成大量额外开销。在这一行中，s是左值，fun()是右值(纯右值)，fun()产生的那个返回值作为一个临时值，一旦str被s复制后，将被销毁，无法获取、也不能修改。

自C++11开始，引入了`move`语义，编译器会将这部分优化成move操作，即不再是之前的复制操作，而是move。此时，str会被进行隐式右值转换，等价于`static_cast<std::string&&>(str)`，进而此处的 s 会将 foo 局部返回的值进行移动。

> 无论是C++11之前的拷贝，还是C++11的move，str在填充(拷贝或者move)给s之后，将被销毁，而被销毁的这个值，就成为将亡值。

**将亡值就定义了这样一种行为：具名的临时值、同时又能够被move。**

### 混合类型

#### 泛左值

``` c++
struct S{
  int n;
};

S fun();
S s;
s;
std::move(s);

fun();
S{};
S{}.n;
```

- 定义了结构体S和函数fun()
- 第6行声明了类型为S的变量s，因为其是具名的，所以是glvalue
- 第七行同上，因为s具名，所以为glvalue
- 第8行中调用了move函数 ，将左值s转换成xvalue，所以是glvaue
- 第10行中，fun()是不具名的，是纯右值，所以不是glvalue
- 第11行中，生成一个不具名的临时变量，是纯右值，所以不是glvalue
- 第12行中，n具名，所以是glvalue

glvalue的特征如下：

- 可以自动转换成prvalue
- 可以是多态的
- 可以是不完整类型，如前置声明但未定义的类类型

#### 右值
右值(rvalue, right value)是指可以移动的表达式。prvalue和xvalue都是rvalue，具体的示例见下文。

rvalue具有以下特征：

- 无法对rvalue进行取地址操作。例如：&1，&(a + b)，这些表达式没有意义，也编译不过。
- rvalue不能放在赋值或者组合赋值符号的左边，例如：3 = 5，3 += 5，这些表达式没有意义，也编译不过。
- rvalue可以用来初始化const左值引用（见下文）。例如：const int& a = 1。
- rvalue可以用来初始化右值引用（见下文）。
- rvalue可以影响函数重载：当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上。

### 引用

既然提到了左值右值，就得提一下引用。

在C++11之前，引用分为左值引用和常量左值引用两种，但是自C++11起，引入了右值引用，也就是说，在C++11中，包含如下3中引用：
- 左值引用
- 常量左值引用（不希望被修改）
- 右值引用

``` c++
int a = 1;
int &rb = a; // b为左值引用
int &&rrb = a; // 错误，a是左值，右值引用不能绑定左值
int &&rrb1 = 1; // 正确，1为右值
int &rb1 = i * 2; // 错误，i * 2是右值，而rb1位左值引用
int &&rrb2 = i * 2; // 正确
const int &c = 1; // 正确
const int &c1 = i * 2; // 正确
```

在这里，我们需要特别注意的一点就是右值引用虽然是引用右值，但是其本身是左值，以下代码为例：

``` c++
int &a = 1;
```

在上述代码中，a是一个右值引用，但是其本身是左值，这是因为：
- a出现在等号(=)的左边
- 可以对a取地址

**我们在前面有提到过，一个表达式有两个属性，分别为类型和值类别。本节说的`左值引用和右值引用就属于类型`,而`左值和右值则属于值类别范畴`，这个概念很重要，千万不能混淆。**

### 系统API

``` c++
std::is_lvalue_reference
is_rvalue_reference
  
int a = 1;
int &ra = a;
int &&b = 1;

std::cout << std::is_lvalue_reference<decltype(ra)>::value << std::endl;

std::cout << std::is_rvalue_reference<decltype(ra)>::value << std::endl;

std::cout << std::is_rvalue_reference<decltype(b)>::value << std::endl;

```

``` c++
1
0
1
```


## 编译器之返回值优化


## 深入理解移动语义

``` c++
#include <cstdlib>
#include <iostream>
#include <vector>

class BigObj {
public:
  explicit BigObj(size_t length) noexcept: length_(length), data_(new int[length]) {
    std::cout << "构造BigObject" << std::endl;
  }

  ~BigObj() {
    if (data_ != nullptr) {
      delete[] data_;
      length_ = 0;
    }
  }

  // 拷贝构造函数
   BigObj(const BigObj &other) noexcept
      : length_(other.length_), data_(new int[other.length_]) {
    std::cout << "使用拷贝构造" << std::endl;
    std::copy(other.data_, other.data_ + length_, data_);
  }
  // 赋值运算符
  BigObj &operator=(BigObj &other) {
    std::cout << "使用赋值" << std::endl;
    if (this != &other) {
      delete[] data_;
      length_ = other.length_;
      data_ = new int[length_];
      std::copy(other.data_, other.data_ + length_, data_);
    }
    return *this;
  }
  // 移动构造函数
  // 这里要将移动构造函数声明为noexcept表示它不会抛出异常，
  // 这样vector<BigObj>在复制时就会使用移动迭代器（就是会包装一层std::move），从而触发移动构造。
  BigObj(BigObj &&other) noexcept{
    std::cout << "使用移动构造" << std::endl;
    data_ = other.data_;
    length_ = other.length_;
    other.data_ = nullptr;
    other.length_ = 0;
  }
  // 移动赋值运算符
  BigObj &operator=(BigObj &&other) {
    std::cout << "使用移动赋值" << std::endl;
    if (this != &other) {
      delete[] data_;
      data_ = other.data_;
      length_ = other.length_;
      other.data_ = nullptr;
      other.length_ = 0;
    }
    return *this;
  }

private:
  size_t length_;
  int *data_;
};

int main() {
  std::vector<BigObj> v;
  std::cout << "TEST1\n";
  v.push_back(BigObj(25));
  v.push_back(BigObj(75));

  std::cout << "TEST2\n";
  v.push_back(BigObj(25));
  v.push_back(BigObj(75));

  std::cout << "TEST3\n";
  v.push_back(BigObj(25));
  v.push_back(BigObj(25));
  v.push_back(BigObj(25));
  v.push_back(BigObj(25));

  std::cout << "TEST4\n";
  v.push_back(BigObj(75));

  //v.insert(v.begin() + 1, BigObj(50));
  return 0;
}

```

### 生成时机

众所周知，在C++中有四个特殊的成员函数：默认构造函数、析构函数，拷贝构造函数，拷贝赋值运算符。之所以称之为特殊的成员函数，这是因为如何开发人员没有定义这四个成员函数，那么编译器则在满足某些特定条件(仅在需要的时候才生成，比如某个代码使用它们但是它们没有在类中明确声明)下，自动生成。这些由编译器生成的特殊成员函数是public且inline。

自C++11起，引入了另外两只特殊的成员函数：移动构造函数和移动赋值运算符。如果开发人员没有显示定义移动构造函数和移动赋值运算符，那么编译器也会生成默认。与其他四个特殊成员函数不同，编译器生成默认的移动构造函数和移动赋值运算符需要，满足以下条件：

- 如果一个类定义了自己的拷贝构造函数,拷贝赋值运算符或者析构函数(这三者之一，表示程序员要自己处理对象的复制或释放问题)，编译器就不会为它生成默认的移动构造函数或者移动赋值运算符，这样做的目的是防止编译器生成的默认移动构造函数或者移动赋值运算符不是开发人员想要的
- 如果类中没有提供移动构造函数和移动赋值运算符，且编译器不会生成默认的，那么我们在代码中通过std::move()调用的移动构造或者移动赋值的行为将被转换为调用拷贝构造或者赋值运算符
- 只有一个类没有显示定义拷贝构造函数、赋值运算符以及析构函数，且类的每个非静态成员都可以移动时，编译器才会生成默认的移动构造函数或者移动赋值运算符
- 如果显式声明了移动构造函数或移动赋值运算符，则拷贝构造函数和拷贝赋值运算符将被 隐式删除（因此程开发人员必须在需要时实现拷贝构造函数和拷贝赋值运算符）
与拷贝操作一样，如果开发人员定义了移动操作，那么编译器就不会生成默认的移动操作，但是编译器生成移动操作的行为和生成拷贝操作的行为有些许不同，如下：

两个拷贝操作是独立的：声明一个不会限制编译器生成另一个。所以如果你声明一个拷贝构造函数，但是没有声明拷贝赋值运算符，如果写的代码用到了拷贝赋值，编译器会帮助你生成拷贝赋值运算符。同样的，如果你声明拷贝赋值运算符但是没有拷贝构造函数，代码用到拷贝构造函数时编译器就会生成它。上述规则在C++98和C++11中都成立。
两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。如果你给类声明了，比如，一个移动构造函数，就表明对于移动操作应怎样实现，与编译器应生成的默认逐成员移动有些区别。如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题。所以声明移动构造函数阻止编译器生成移动赋值运算符，声明移动赋值运算符同样阻止编译器生成移动构造函数。

## 内存泄露

## 智能指针
