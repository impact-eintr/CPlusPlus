# CPP面试大全——语言特性

<hr>

## 关键字
### static
#### static全局变量与普通全局变量
>  相同点

- 存储方式 普通全局变量和static全局变量都是静态存储方式(编译时分配内存)

> 不同点

- 作用域
  - 普通全局变量的作用于是整个源程序,当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的
  - 静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它
  - 由于静态全局变量的作用域限于一个源文件（编译模块）内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误
  例如在a.c中定义了static int a=10; 那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中。
- 初始化
  - 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值（比如整型的0）初始化它
  - 用static声明局部变量-------局部变量指在代码块 {} 内部定义的变量，只在代码块内部有效（作用域），用static声明局部变量时，则改变变量的存储方式（生命期），使变量成为静态的局部变量，即编译时就为变量分配内存，直到程序退出才释放存储单元。这样，使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用（作用域不变）
  - 修饰成员变量，在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
  
#### static修饰函数
- 修饰普通函数  修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static
> 如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可

- 修饰成员函数
  - 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名
  - 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）
  - 如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：`<类名>::<静态成员函数名>(<参数表>)`

> 返回函数中静态变量的地址会发生什么？

``` c++
#include <iostream>
using namespace std;

int * fun(int tmp){
    static int var = 10; // var会在编译阶段就分配在静态区
    var *= tmp;
    return &var;
}

int main() {
    cout << *fun(5) << endl;
    return 0;
}

/*
运行结果：
50
*/
```

说明：上述代码中在函数 fun 中定义了静态局部变量 var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。

#### static什么时候初始化
- 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存
- 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。\
  - 在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收
  - 而在C++中，**初始化时在执行相关代码时才会进行初始化**，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的

#### static在类中使用
**static静态成员变量**
1. 静态成员变脸是在类内进行声明， 在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现static关键字和private public protected访问规则 
2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，**包括派生类的对象**
3. **静态成员变脸可以作为成员函数的参数，而普通成员变量不可以**

``` c++
#include <iostream>
using namespace std;

class A
{
public:
    static int s_var;
    int var;
    void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数
    void fun2(int i = var);   //  error: invalid use of non-static data member 'A::var'
};
int main()
{
    return 0;
}
```
4. 静态数据成员的类型可以是所属类的类型，==而普通数据成员的类型只能是该类类型的指针或引用==。
```c++
#include <iostream>
using namespace std;

class A
{
public:
    static A s_var; // 正确，静态数据成员
    A var;          // error: field 'var' has incomplete type 'A'
    A *p;           // 正确，指针
    A &var1;        // 正确，引用
};

int main()
{
    return 0;
}
```

**static静态成员函数**
1. 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有this指针，必须通过类名才能访问。静态成员函数作为类作用域的全局函数。
2. 静态成员函数不能声明成虚函数、const函数和volatile函数

### volatile
#### volatile 的作用？是否具有原子性，对编译器有什么影响？
- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值），保证对特殊地址的稳定访问
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile 
- volatile不具有原子性。
- 注意
  - 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。
  - 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。
  - C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从==类传递到它的成员。==

#### 什么情况下一定要用 volatile， 能否和 const 一起使用？
使用 volatile 关键字的场景：
- 当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰
- 中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰
> 关键字volatile有什么含意?

答案：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

> volatile关键字

``` c++
volatile int i = 10;
```

- volatile关键字是一种类型修饰符，用它声明的类型变量可以被某些编译器位置的罂因素(操作系统、硬件、其他线程)更改。所以使用volatile告诉编译器不应该对这样的对象进行优化
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

> const, volatile区别

1. const含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”，是不可修改的只读变量。 volatile的含义是“请不要做自以为是的优化，这个值可能变掉的”，而并非“你可以修改这个值”。
2. 
- const只在编译期有用，在运行期无用
  - const在编译期保证在C的“源代码”里面，没有对其修饰的变量进行修改的地方（如有则报错，编译不通过），而运行期该变量的值是否被改变则不受const的限制。
- volatile在编译期和运行期都有用
  - 在编译期告诉编译器：请不要做自以为是的优化，这个变量的值可能会变掉；
  - 在运行期：每次用到该变量的值，都直接从内存中取该变量的值。
3. const, volatile同时修饰一个变量
- 合法性
  - `volatile`的含义并非是`non-const`,`volatile`和`const`不构成反义词，所以可以放在一起修饰一个变量
-  修饰同一个变量的含义
  - 表示一个变量在策划那个续编译器见不能被修改且不能被优化
  - 在程序运行期间，变量值可以修改，但每次用到该变量的值都要从内存中取用，以防止意外错误
### extern
> 请你来说一说extern“C”
- 被 extern 限定的函数或变量是 extern 类型的
- 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和链接的 extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。


> extern "C" 使用

``` c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

> extern C为什么需要？

基本解释：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

也就是说extern有两个作用。第一，当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的。

第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
### const
> 作用
- const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
- const 修饰函数参数，使得传递过来的函数参数的值不能改变。
- const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
> 在类中的用法

- `const` 成员变量

1. const 成员变量只能在类内声明定义，在构造函数初始化列表中初始化
2. cosnt 成员变量只能在某个对象的生命周期内是常量，对于整个类而言确实可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。

- `const` 成员函数

不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。 不能调用非常量成员函数，以防修改成员变量的值。

``` c++
#include <iostream>
using namespace std;

class A
{
public:
	int var;
	A(int tmp) : var(tmp) {}
	void c_fun(int tmp) const // const 成员函数
	{
		var = tmp; // error: assignment of member 'A::var' in read-only object. 在 const 成员函数中，不能修改任何类成员变量。		
		fun(tmp); // error: passing 'const A' as 'this' argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
	}

	void fun(int tmp)
	{
		var = tmp;
	}
};

int main()
{
    return 0;
}
```

> 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？
常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。
- 对于局部对象，常量存放在栈区
- 对于全局对象，常量存放在全局/静态存储区
- 对于字面值常量，常量存放在常量存储区

> const作用 "只读"

1. const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。

``` c++
TYPE const ValueName = value;

const TYPE ValueName = value;
```

2. 修饰指针
- 指向常量的指针 (pointer to const) const int*
- 自身是常量的指针  (const pointer) int* const

3. 修饰引用
- 指向常量的引用（reference to const）如果用于形参类型，即避免了拷贝，又避免了函数对值的修改； const int&
- 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰 no int& const

> const 使用

**实际上const和*的优先级相同，且是从右相左读的，即“右左法则”**

``` c++
比如int*p;//读作p为指针，指向int，所以p为指向int的指针

int*const p;//读作p为常量，是指针，指向int，所以p为指向int的常量指针， p不可修改

int const *p;//p为指针，指向常量，为int，所以p为指向int常量的指针， *p不可修改

int ** const p; //p为常量，指向指针，指针指向int，所以p为指向int型指针的常量指针，p不可修改

const int **p;//指向常量指针的指针

int const**p; //p为指针，指向指针，指针指向常量int，所以p为指针，指向一个指向int常量的指针， **p为int，不可修改

int * const *p ; //p为指针，指向常量，该常量为指针，指向int，所以p为指针，指向一个常量指针，*p为指针，不可修改

int ** const *p; //p为指针，指向常量，常量为指向指针的指针，p为指针，指向常量型指针的指针，*p为指向指针的指针，不可修改

int * const **p; //p为指针，指向一个指针1，指针1指向一个常量，常量为指向int的指针，即p为指针，指向一个指向常量指针的指针， **p为指向一个int的指针，不可修改

```

``` c++
// 类
class A
{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";      //字符串hello保存在栈区，可以通过greeting去修改
    const char * arr = "123"; //字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样
    char * brr = "123"; //字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值
    const char crr[] = "123";

//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
//确实，经过简单测试const char crr[]="123"; crr[1]='5';结果报错
//error: assignment of read-only location ‘crr[1]’
    
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明不能通过p2修改greeting，但是greeting在栈上可以通过其它方式修改，比如下标，和p1来修改）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变，即指针不能指向其它地址，但可以修改其中的值）
    //比如*(p2+1)='c'; 则报错assignment of read-only location ‘*(p2 + 1u)’
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

```

> 在函数中使用const
### inline


### mutable
mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。

### using 
> using 声明

`using namespace_name::name;`
一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。

> using 指示

`using namespace_name name;`
using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。

### 委托构造（delegating constructor）

如果你的类有多个不同形式的构造函数，为了初始化成员肯定会有大量的重复代码。为了避免重复，常见的做法是把公共的部分提取出来，放到一个 init() 函数里，然后构造函数再去调用。这种方法虽然可行，但效率和可读性较差，毕竟 init() 不是真正的构造函数。

在 C++11 里，你就可以使用“委托构造”的新特性，一个构造函数直接调用另一个构造函数，把构造工作“委托”出去，既简单又高效。

``` c++

class DemoDelegating final
{
private:
    int a;                              // 成员变量
public:
    DemoDelegating(int x) : a(x)        // 基本的构造函数
    {}

    DemoDelegating() :                 // 无参数的构造函数
        DemoDelegating(0)               // 给出默认值，委托给第一个构造函数
    {}

    DemoDelegating(const string& s) : // 字符串参数构造函数
        DemoDelegating(stoi(s))        // 转换成整数，再委托给第一个构造函数
    {}
};
```

### 成员初始化列表
> 成员初始化列表好处

- 更高效：少了一次调用默认构造函数的过程。
- 有些场合必须要用初始化列表：
  - 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
  - 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
  - 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化

### 类型别名

C++11 扩展了关键字 using 的用法，增加了 typedef 的能力，可以定义类型别名。它的格式与 typedef 正好相反，别名在左边，原名在右边，是标准的赋值形式，所以易写易读。

``` c++
using uint_t = unsigned int; // using 别名
typedef unsigned int uint_t;
```

### 可调用对象

``` c++
#include <cstdlib>
#include <iostream>

struct adder {
  adder(int n) :_n(n) {}
  int operator() (int x) const {
    return x + _n;
  }
private:
  int _n;
};

int main() {
  auto add_2 = adder(2);
  adder add_3(3);
  std::cout << add_2(20) << " " << add_3(30) << std::endl;
}

```

### 函数的指针和引用

除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。不管是函数指针还是函数引用，你也都可以当成函数对象来用。

``` c++
int add_2(int x)
{
  return x + 2;
};

template <typename T>
auto test1(T fn)
{
  return fn(2);
}

template <typename T>
auto test2(T& fn)
{
  return fn(2);
}

template <typename T>
auto test3(T* fn)
{
  return (*fn)(2);
}
```

当我们拿 add_2 去调用这三个函数模板时，fn 的类型将分别被推导为 `int (*)(int)`、`int (&)(int) `和 `int (*)(int)`。不管我们得到的是指针还是引用，我们都可以直接拿它当普通的函数用。当然，在函数指针的情况下，我们直接写 *value 也可以。因而上面三个函数拿 add_2 作为实参调用的结果都是 4。

很多接收函数对象的地方，也可以接收函数的指针或引用。但在个别情况下，需要通过函数对象的类型来区分函数对象的时候，就不能使用函数指针或引用了——原型相同的函数，它们的类型也是相同的。

### function模板
每一个 lambda 表达式都是一个单独的类型，所以只能使用 auto 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用 function 模板。

function 模板的参数就是函数的类型，一个函数对象放到 function 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。注意 function 对象的创建还是比较耗资源的，所以请你只在用 auto 等方法解决不了问题的时候使用这个模板。

``` c++
#include <cstdlib>
#include <iostream>
#include <map>
#include <string>
#include <functional>

using std::map;
using std::string;
using std::function;

struct adder {
  adder(int n) :_n(n) {}
  int operator() (int x) const {
    return x + _n;
  }
private:
  int _n;
};

int main() {
  auto add_2 = adder(2);

  adder add_3(3);

  std::cout << add_2(20) << " " << add_3(30) << std::endl;

  map<string, function<int(int, int)>> op_dict{
    {"+", [](int x, int y){
      return x + y;
    }},
    {"-", [](int x, int y){
      return x - y;
    }},
    {"*", [](int x, int y){
      return x * y;
    }},
    {"/", [](int x, int y){
      return x / y;
    }},
  };

  std::cout << op_dict["+"](add_2(20), add_3(30)) << std::endl;

}

```

### lambda


``` c++
  auto add_2 = []int(int x) {
    reutnr x + 2;
  }
  
  auto adder = [](int n) {
    return [n] (int x) {
      return x + n;
    };
  };
```

- Lambda 表达式以一对中括号开始
- 跟函数定义一样，我们有参数列表
- 跟正常的函数定义一样，我们会有一个函数体，里面会有 return 语句
- Lambda 表达式一般不需要说明返回值（相当于 auto）；有特殊情况需要说明时，则应使用箭头语法的方式：[](int x) -> int { … }
- 每个 lambda 表达式都有一个全局唯一的类型，要精确捕捉 lambda 表达式到一个变量中，只能通过 auto 声明的方式
- 中括号中写了 n 来捕获变量 n 的数值。这个函数的实际效果和前面的 adder 函数对象完全一致。也就是说，捕获 n 的效果相当于在一个函数对象中用成员变量存储其数值。

#### 变量捕获
变量捕获的开头是可选的默认捕获符 = 或 &，表示会自动按值或按引用捕获用到的本地变量，然后后面可以跟（逗号分隔）：
- 本地变量名标明对其按值捕获（不能在默认捕获符 = 后出现；因其已自动按值捕获所有本地变量）
- & 加本地变量名标明对其按引用捕获（不能在默认捕获符 & 后出现；因其已自动按引用捕获所有本地变量）
- this 标明按引用捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况）；注意默认捕获符 = 和 & 号可以自动捕获 this（并且在 C++20 之前，在 = 后写 this 会导致出错）
- *this 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）
- 变量名 = 表达式 标明按值捕获表达式的结果（可理解为 auto 变量名 = 表达式）
- &变量名 = 表达式 标明按引用捕获表达式的结果（可理解为 auto& 变量名 = 表达式）

### 类模板的模板参数推导

``` c++
pair<int, int> pr{1, 42};

auto pr = make_pair(1, 42);
```

c++17之后

``` c++
pair pr{1, 42};
```

### 类数据成员的默认初始化
按照 C++98 的语法，数据成员可以在构造函数里进行初始化。这本身不是问题，但实践中，如果数据成员比较多、构造函数又有多个的话，逐个去初始化是个累赘，并且很容易在增加数据成员时漏掉在某个构造函数中进行初始化。为此，C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化。

``` c++

class Complex {
public:
  Complex() {}
  Complex(float re) : re_(re) {}
  Complex(float re, float im)
    : re_(re) , im_(im) {}

private:
  float re_{0};
  float im_{0};
};
```

第一个构造函数没有任何初始化列表，所以类数据成员的初始化全部由默认初始化完成，re_ 和 im_ 都是 0。第二个构造函数提供了 re_ 的初始化，im_ 仍由默认初始化完成。第三个构造函数则完全不使用默认初始化。

==在初始化时，{}前面的等于号是否书写对初始化行为没有影响。==

### 可变参数模板
可变参数模板： C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数。
可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号“...”。比如我们常常这样声明一个可变模版参数：template<typename...>或者template<class...>，一个典型的可变模版参数的定义是这样的：

`template <class... T>
void f(T... args);`

上面的可变模版参数的定义当中，省略号的作用有两个：

1. 声明一个参数包T... args，这个参数包中可以包含0到任意个模板参数；
2. 在模板定义的右边，可以将参数包展开成一个一个独立的参数。

上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（N>=0）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。

　　可变模版参数和普通的模版参数语义是一致的，所以可以应用于函数和类，即可变模版参数函数和可变模版参数类，然而，模版函数不支持偏特化，所以可变模版参数函数和可变模版参数类展开可变模版参数的方法还不尽相同，下面我们来分别看看他们展开可变模版参数的方法。


#### 可变模版参数函数

``` c++
#include <iostream>

using namespace std;

namespace VariadicTemplates{
  void printX() {

  }

  template <typename T, typename... Types>
  void printX(const T& firstArg, const Types&... args) {
    cout << firstArg << endl;
    printX(args...);
  }
}

int main(int argc, char *argv[]) {
  VariadicTemplates::printX(1.2, 1, "gg");
  return 0;
}

// Max/Min
int maximum(int n) { return n; }

template <typename... Args> int maximum(int n, Args... args) {
  return max(n, maximum(args...));
}

int main() {
  int a, b, c = 1, 2, 3;
  cout << max(a, b, c) << endl;
}

```

#### 可变模版参数类

``` c++
// 模拟tuple内部实现
template <typename... Values> class _tuple; // 这里表示_tuple是一个模板类

template <> class _tuple<> {
public:
  _tuple() {}
};

template <typename Head, typename... Tail> //不希望产生实参个数为0的变长参数模板
class _tuple<Head, Tail...> : private _tuple<Tail...> //继承自参数少一个的tuple
{
  typedef _tuple<Tail...> inherited;

protected:
  Head m_head;

public:
  _tuple() = default;
  _tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) {}

  auto head() -> decltype(m_head) { return m_head; } //使用decltype进行类型推导
  //	Head head(){ return m_head; }
  inherited &tail() { return *this; } // return后转换为inherited
};


int main(int argc, char *argv[]) {
  VariadicTemplates::_tuple<int,float,string> t(41,6.3,"nico");
  cout << t.head() <<endl;
  cout << t.tail().head() <<endl;
  cout << t.tail().tail().head() <<endl;
  return 0;
}

```

#### 可变参数模版实现泛化的delegate

#### 总结
使用可变模版参数的这些技巧相信读者看了会有耳目一新之感，使用可变模版参数的关键是如何展开参数包，展开参数包的过程是很精妙的，体现了泛化之美、递归之美，正是因为它具有神奇的“魔力”，所以我们可以更泛化的去处理问题，比如用它来消除重复的模版定义，用它来定义一个能接受任意参数的“万能函数”等。其实，可变模版参数的作用远不止文中列举的那些作用，它还可以和其它C++11特性结合起来，比如type_traits、std::tuple等特性，发挥更加强大的威力，将在后面模板元编程的应用中介绍。


### 类型转换

#### reinterpret_cast
- 用于位的简单重新解释
- 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
- 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全）
- 也允许将任何整数类型转换为任何指针类型以及反向转换。
- reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。

#### const_cast
用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）

#### static_cast
- 用于非多态类型的转换
- 不执行运行时类型检查（转换安全性不如 dynamic_cast）
- 通常用于转换数值数据类型（如 float -> int）
- 用于各种隐式转换，比如非const转const
- 任意类型与空指针类型void* 之间的转换。
- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）

``` c++
//基本类型转换 
int i=0; 
double d = static_cast<double>(i); //相当于 double d = (double)i; 
//转换继承类的对象为基类对象 
class Base{}; 
class Derived : public Base{}; 
Derived d; 
Base b = static_cast<Base>(d); //相当于 Base b = (Base)d; 
```

#### dynamic_cast
- 与static_cast相对, 用于多态类型的转换(动态转换)
- 执行行运行时类型检查, 并非在编译时进行，
- 只适用于指针或引用
- 可以在整个类层次结构中移动指针，包括向上转换(子类向基类)、向下转换(基类向子类)

#### 为什么不使用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。


### 智能指针
#### shared_ptr

多个智能指针可以共享同一个对象，对象的最末一个拥有责任销毁对象，并清理与该对象相关的所有资源。

- 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁
#### unique_ptr

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以==帮助避免资源泄漏==的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有者被销毁或变成empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

- unique_ptr 用于取代 auto_ptr

#### weak_ptr

weak_ptr 允许共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

- 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

#### auto_ptr（被 C++11 弃用）

- 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵；
- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
- auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；

## 指针和引用

### 指针和数组
#### 请回答一下C语言数组和指针的区别
| 指针                                                                   | 数组                                 |
|:----------------------------------------------------------------------:|:------------------------------------:|
| 保存数据的地址                                                         | 保存数据                             |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据                         |
| 通常用于动态的数据结构                                                 | 通常用于固定数目且数据类型相同的元素 |
| 通过Malloc分配内存，free释放内存                                       | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数                                         | 自身即为数据名                       |
- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。

> 什么时候数组会退化？

传参的时候呗

> 判断一下以下情况

- A.一个整型数？

答案：int a;

- B.一个指向整型数的指针？

答案：int *a;

- C.一个指向指针的的指针，它指向的指针是指向一个整型数？

答案：int **a;

- D.一个有10个整型数的数组？

答案：int a[10];

- E.一个有10个指针的数组，该指针是指向一个整型数的？

答案：int *a[10]; // []的优先级更高, 优先为数组

- ==F.一个指向有10个整型数数组的指针?==

答案：int (*a)[10];

- G.一个指向函数的指针，该函数有一个整型参数并返回一个整型数?

答案：int (*a)(int);

- H.一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数?

答案：int (*a[10])(int);

### 野指针和悬空指针

> 请你回答一下野指针是什么？
野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针

> 野指针产生的原因：
1. 指针定义时未被初始化：指针在被定义的时候，如果程序不对其进行初始化的话，它会随机指向一个区域，因为任意指针变量（出了static修饰的指针）它的默认值都是随机的 
2. 指针被释放时没有置空：我们在用malloc（）开辟空间的时候，要检查返回值是否为空，如果为空，则开辟失败；如果不为空，则指针指向的是开辟的内存空间的首地址。指针指向的内存空间在用free()和delete释放后，如果程序员没有对其进行置空或者其他赋值操作的话，就会成为一个野指针 
3. 指针操作超越变量作用域：不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放。

> 野指针的危害：
问题：指针指向的内容已经无效了，而指针没有被置空，解引用一个非空的无效指针是一个未被定义的行为，也就是说不一定导致错误，野指针被定位到是哪里出现问题，在哪里指针就失效了，不好查找错误的原因。

> 规避方法：
初始化指针的时候将其置为nullptr，之后对其操作。 释放指针的时候将其置为nullptr。

> 空指针、野指针与悬空指针的区别：

- 空指针：指被赋值为NULL的指针；空指针可以被多次delete

- 野指针：访问一个已销毁或者访问受限的内存区域的指针，野指针不能判断是否为NULL来避免。

- 悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。悬垂指针再次删除时程序会变得非常不稳定。



### 函数指针

1. 定义 函数指针是指向函数的指针变量。

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

2. 用途：

调用函数和做函数的参数，比如回调函数。

3. 示例：

``` c++
char * fun(char * p)  {…}       // 函数fun
char * (*pf)(char * p);             // 函数指针pf
pf = fun;                        // 函数指针pf指向函数fun
pf(p);                        // 通过函数指针pf调用函数fun

```

### nullptr

``` c++
const class nullptr_t{
public:
    template<class T>  inline operator T*() const{ return 0; }
    template<class C, class T> inline operator T C::*() const { return 0; }
private:
    void operator&() const;
} nullptr = {};
```

### 对象指针
指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。 特别注意：定义指向成员函数的指针时，要标明指针所属的类。

### this指针
this 指针：指向类的当前对象的指针常量
1. this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. this 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
6. 在以下场景中，经常需要显式引用 this 指针：
  - 为实现对象的链式引用；
  - 为避免对同一对象进行赋值操作；
  - 在实现一些数据结构时，如 list。
  
> 几个this指针的易混问题：
- A. this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面进行处理

- B. this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

- C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？

大多数编译器通过ecx（计数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

- D. this指针是如何访问类中的变量的？

如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构体的指针了。

- E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

**this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

- F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰

### 指针和引用
请说一下C/C++ 中指针和引用的区别？
定义：
1、引用：

C ++ 是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。

2、指针：

指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

> 指针与引用的区别
1. 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：`int a=1;int *p=&a;int a=1;int &b=a;`前面两句定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而后面两句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

2. 引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。

3. 可以有const指针，但是没有const引用；

4. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

5. 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

7. ”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；

8. 指针和引用的自增(++)运算意义不一样；

9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；

> 引用带来的好处： 
用指针的使用经常犯得错：1，操作空指针.2，操作野指针.3，误操作改变了指针的值，而后还以为该指针正常。如果我们要正确的使用指针，我们不得不人为地保证这三个条件。
而引用的提出就解决了这个问题。 引用区别于指针的特性是 ：1，不存在空引用（保证不操作空指针），2，必须初始化（保证不是野指针），3，一个引用永远指向他初始化的那个对象，一旦初始化就不能改变初始化的值（保证指针值不变）。人为保证变为了编译器来保证，更加安全。

### 右值

#### 右值和移动究竟解决了什么问题

#### 右值和左值

#### 右值引用

#### 转移语意

#### 完美转发

#### move实现原理


## 内存管理

### 编译链接

#### 程序编译过程
![img](https://camo.githubusercontent.com/c313c7a4d95e1db396e1400b254036c125690aa5d043784a2904b5030afce49e/68747470733a2f2f7069632e6c656574636f64652d636e2e636f6d2f313631323637363934362d4856766b64522d696d6167652e706e67)

对于C++源文件，从文本到可执行文件一般需要四个过程：

1. **预处理阶段**：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
2. **编译阶段**：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
3. **汇编阶段**：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
4. **链接阶段**：将多个目标文件及所需要的库连接成最终的可执行目标文件

> 请你说一下源码到可执行文件的过程

1. 预编译
主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下

  1、删除所有的#define，展开所有的宏定义。
  
  2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
  
  3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。
  
  4、删除所有的注释，“//”和“/**/”。
  
  5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。
  
  6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。

2. 编译
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

  1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
  
  2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
  
  3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
  
  4、优化：源代码级别的一个优化过程。
  
  5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
  
  6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

3. 汇编
  将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。

4. 链接
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：

  1. 静态链接：

  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
  
  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
  
  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
  
  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

  2. 动态链接：

  动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
  
  共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
  
  更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
  
  性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

#### #include
> 请你来回答一下include头文件的顺序以及双引号和尖括号的区别？
- Include头文件的顺序：
对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。

- 双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。
1. 对于使用双引号包含的头文件，查找头文件路径的顺序为：
- 当前头文件目录
- 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）
- 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

2. 对于使用尖括号包含的头文件，查找头文件的路径顺序为：
- 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）
- 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径
#### 动态链接与静态链接

#### main前
你来写个函数在main函数执行前先运行
方法一：

全局变量的构造函数，会在main之前执行。

``` c++
#include <iostream>
using namespace std;

class app
{
public:
    //构造函数
    app()
    {
        cout<<"First"<<endl;
    }
};

app a;  // 申明一个全局变量

int main()
{
    cout<<"Second"<<endl;
    return 0;
}
```

方法二：

全局变量的赋值函数，会在main之前执行。（C中好像不允许通过函数给全局变量赋值）

``` c++
#include <iostream>
using namespace std;

int f(){
    printf("before");
    return 0;
}

int _ = f();

int main(){
    return 0;
}
```

方法三：

如果是GNUC的编译器（gcc，clang），就在你要执行的方法前加上 __attribute__((constructor))

``` c++
#include<stdio.h>

__attribute__((constructor)) void func()
{
    printf("hello world\n");
}

int main()
{
    printf("main\n"); //从运行结果来看，并没有执行main函数
}
```


同理，如果想要在main函数结束之后运行，可加上_sttribute_((destructor)).

``` c++
#include<stdio.h>

void func()
{
    printf("hello world\n");
    //exit(0);
    return 0;
}

__attribute((constructor))void before()
{
    printf("before\n");
    func();
}


__attribute((destructor))void after()
{
    printf("after\n");

}

int main()
{
    printf("main\n"); //从运行结果来看，并没有执行main函数
}
```


#### 模板的编译与链接
<!-- TODO -->

#### 各个平台相关
> 内存、栈、堆

一般应用程序内存空间有如下区域：

- 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文
- 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域
- 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里
- 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据

> 栈
- 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：

  - 函数的返回地址和参数
  - 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
  - 保存上下文：包括函数调用前后需要保持不变的寄存器
> 堆

堆分配算法：

- 空闲链表（Free List）
- 位图（Bitmap）
- 对象池

### 内存对齐

#### 结构体大小
和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。

``` c++
struct stu1
{
     int i;
     char c;
     int j;
}；
```
用sizeof求该结构体的大小，发现值为12。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？

先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。

然而，在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：

（1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）

（2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。

上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。

> 没有成员的结构体占用的空间是多少个字节？

答案是：1个字节。

这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。
#### 类的大小
- 遵循结构体的对齐原则。
- 与普通成员变量有关，与==成员函数和静态成员无关==。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。
- 虚函数对类的大小有影响，是因为虚函数表指针的影响。
- 虚继承对类的大小有影响，是因为虚基表指针带来的影响。
- 空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间(占一个就有空间了)。

``` c++
/*
说明：程序是在 64 位编译器下测试的
*/
#include <iostream>

using namespace std;

class A
{
private:
    static int s_var; // 不影响类的大小
    const int c_var;  // 4 字节
    int var;          // 8 字节 4 + 4 (int) = 8
    char var1;        // 12 字节 8 + 1 (char) + 3 (填充) = 12
public:
    A(int temp) : c_var(temp) {} // 不影响类的大小
    ~A() {}                    // 不影响类的大小
};

class B
{
};
int main()
{
    A ex1(4);
    B ex2;
    cout << sizeof(ex1) << endl; // 12 字节
    cout << sizeof(ex2) << endl; // 1 字节
    return 0;
}
```

``` c++
/*
说明：程序是在 64 位编译器下测试的
*/
#include <iostream>

using namespace std;

class A
{
private:
    static int s_var; // 不影响类的大小
    const int c_var;  // 4 字节
    int var;          // 8 字节 4 + 4 (int) = 8
    char var1;        // 12 字节 8 + 1 (char) + 3 (填充) = 12
public:
    A(int temp) : c_var(temp) {} // 不影响类的大小
    ~A() {}                      // 不影响类的大小
    virtual void f() { cout << "A::f" << endl; }

    virtual void g() { cout << "A::g" << endl; }

    virtual void h() { cout << "A::h" << endl; } // 24 字节： 12 + 4 (填充) + 8 (指向虚函数的指针) = 24
};

int main()
{
    A ex1(4);
    A *p;
    cout << sizeof(p) << endl;   // 8 字节 注意：指针所占的空间和指针指向的数据类型无关
    cout << sizeof(ex1) << endl; // 24 字节
    return 0;
}
```

#### 内存对齐原因
1. 进行内存对齐的原因：（主要是硬件设备方面的问题）
- 某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；
- 某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；
- 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；
- 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；
- 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。
2. 内存对齐的优点：
- 便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；
- 提高内存的访问效率，：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。


### 运行时内存
内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。

进一步解释：

- 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。

> 内存泄漏的分类：
- 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.

- 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

- 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

> Heap leak

``` c++
char* p = (char *)malloc(10);
char *p1 = (char *)malloc(10);
p = p1;
```
开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。

> 内存泄漏和内存溢出的区别和联系
1. 内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
2. 内存溢出 out of memory : OOM,即所谓的内存溢出。指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。

#### 防止内存泄露
**如果临时变量是第一次出现，那么调用的只能是拷贝构造函数，反之如果变量已经存在，那么调用的就是赋值函数**


``` c++
#include <iostream>
#include <cstring>

 using namespace std;
 class A
 {
 private:
     char *p;
     unsigned int p_size;
     int *p_count; // 计数变量
 public:
     A(unsigned int n = 1) // 在构造函数中申请内存
     {
         p = new char[n];
         p_size = n;
         p_count = new int;
         *p_count = 1;
         cout << "count is : " << *p_count << endl;
     };
     A(const A &temp)
     {
         p = temp.p;
         p_size = temp.p_size;
         p_count = temp.p_count;
         (*p_count)++; // 复制时，计数变量 +1
         cout << "count is : " << *p_count << endl;
     }
     ~A()
     {
         (*p_count)--; // 析构时，计数变量 -1
         cout << "count is : " << *p_count << endl; 

         if (*p_count == 0) // 只有当计数变量为 0 的时候才会释放该块内存空间
         {
             cout << "buf is deleted" << endl;
             if (p != NULL) 
             {
                 delete[] p; // 删除字符数组
                 p = NULL;   // 防止出现野指针
                 if (p_count != NULL)
                 {
                     delete p_count;
                     p_count = NULL;
                 }
             }
         }
     };
     char *GetPointer()
     {
         return p;
     };
 };
 void fun()
 {
     A ex(100);
     char *p = ex.GetPointer();
     strcpy(p, "Test");
     cout << p << endl;

     A ex1 = ex; // 此时计数变量会 +1
     cout << "ex1.p = " << ex1.GetPointer() << endl;
 }
 int main()
 {
     fun();
     return 0;
 }
```


或者使用智能指针

#### 内存管理
> 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？

# 类与对象

## 面向对象
#### 什么是面向对象编程
> cpp面向对象的三个基本特征

- 封装可以隐藏实现细节，使得代码模块化；(使用函数指针把属性与方法封装到结构体中)，将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

- 继承可以扩展已存在的代码模块（类）；它们的目的都是为了代码重用。(结构体嵌套)子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

- 多态是为了实现的目的是为了接口重用(父类与子类方法的函数指针不同)。多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。


> public和protected和private
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- public成员，可以被任意实体访问
- protected成员，只允许被本类和派生类的成员函数访问。
- private成员，只允许本类的成员函数、友元类或友元函数访问

#### 重载、重写、隐藏
- 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，**重载不关心函数返回类型。**
- 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。**基类也可能隐藏派生类**

``` c++
#include <iostream>
using namespace std;

class Base {
public:
    void fun(int tmp, float tmp1) { cout << "Base::fun(int tmp, float tmp1)" << endl; }
};

class Derive : public Base {
public:
    void fun(int tmp) { cout << "Derive::fun(int tmp)" << endl; } // 隐藏基类中的同名函数
};

int main() {
    Derive ex;
    ex.fun(1);       // Derive::fun(int tmp)
    ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided
    return 0;
}
```

``` c++
int main() {
    Base *base = new Derive();
    base->fun(1);           // "Base::func()"   隐藏了Derive的func()
}
/*error: no matching function for call to 'Base::fun(int)'
note: candidate: 'void Base::fun(int, float)'
note: candidate expects 2 arguments, 1 provided
*/
```

注意与虚函数区分，只有没加`virtual`修饰的函数才会发生隐藏现象。

- 重写(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。**重写的基类中被重写的函数必须有 virtual 修饰。**

``` c++
#include <iostream>
using namespace std;

class Base
{
public:
    virtual void fun(int tmp) { cout << "Base::fun(int tmp) : " << tmp << endl; }
};

class Derived : public Base
{
public:
    virtual void fun(int tmp) { cout << "Derived::fun(int tmp) : " << tmp << endl; } // 重写基类中的 fun 函数
};
int main()
{
    Base *p = new Derived();
    p->fun(3); // Derived::fun(int) : 3
    return 0;
}
```

##### 重写和重载的区别：
- 范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。

- 参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。

- virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。

##### 隐藏和重写，重载的区别：
- 范围区别：隐藏与重载范围不同，隐藏发生在不同类中。

- 参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。
## 多态

### RTTI
在虚函数表中，不一定完全是指向虚函数实现的指针。当指定编译器打开RTTI(Run Time Type Identification)开关时，先讲讲RTTI这一机制，和很多其他语言一样，C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。

``` c++
#include <iostream>
using namespace std;

class Flyable                       // 能飞的
{
public:
    virtual void takeoff() = 0;     // 起飞
    virtual void land() = 0;        // 降落
};
class Bird : public Flyable         // 鸟
{
public:
    void foraging() {...}           // 觅食
    virtual void takeoff() {...}
    virtual void land() {...}
    virtual ~Bird(){}
};
class Plane : public Flyable        // 飞机
{
public:
    void carry() {...}              // 运输
    virtual void takeoff() {...}
    virtual void land() {...}
};

class type_info
{
public:
    const char* name() const;
    bool operator == (const type_info & rhs) const;
    bool operator != (const type_info & rhs) const;
    int before(const type_info & rhs) const;
    virtual ~type_info();
private:
    ...
};

void doSomething(Flyable *obj)                 // 做些事情
{
    obj->takeoff();

    cout << typeid(*obj).name() << endl;        // 输出传入对象类型（"class Bird" or "class Plane"）

    if(typeid(*obj) == typeid(Bird))            // 判断对象类型
    {
        Bird *bird = dynamic_cast<Bird *>(obj); // 对象转化
        bird->foraging();
    }

    obj->land();
}

int main(){
	Bird *b = new Bird();
	doSomething(b);
	delete b;
	b = nullptr;
	return 0;
}
```

### 虚函数

#### 虚函数机制
- 虚函数表存放的内容：类的虚函数的地址。

- 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。

- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。

**注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段(.roadata)中。**

- 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。

- 如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。

- 如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。

- 如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。

##### 内存分布
假设有一个基类ClassA，一个继承了该基类的派生类ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。 我们在代码中运用多态这个特性时，通常以两种方式起手： (1) `ClassA *a = new ClassB();` (2) `ClassB b; ClassA *a = &b;` 以上两种方式都是用基类指针去指向一个派生类实例，区别在于第1个用了new关键字而分配在堆上，第2个分配在栈上。
![img](https://camo.githubusercontent.com/58184d0f2205c87d2070ae1b1cf6fee334fc9bcf29543ae43ab320889da32db6/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138303832303134333634343136383f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c334678587a4d324d7a55354d4449792f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730)
请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。 以左图为例，`ClassA *a`是一个栈上的指针。 该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向**该类的虚函数表(这里是类ClassB)**的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。

![img](https://camo.githubusercontent.com/ac65ad02c76f4295bf7024cec50d997c6e3345505241df92761b0e019502c839/68747470733a2f2f75706c6f616466696c65732e6e6f77636f6465722e636f6d2f696d616765732f32303139303331332f3331313433365f313535323437303932303734315f3744343043454633393531413130463632363330313134384530364438394441)

``` c++
class ClassA
{
public:
	ClassA() { cout << "ClassA::ClassA()" << endl; }
	virtual ~ClassA() { cout << "ClassA::~ClassA()" << endl; }

	void func1() { cout << "ClassA::func1()" << endl; }
	void func2() { cout << "ClassA::func2()" << endl; }

	virtual void vfunc1() { cout << "ClassA::vfunc1()" << endl; }
	virtual void vfunc2() { cout << "ClassA::vfunc2()" << endl; }
private:
	int aData;
};

class ClassB : public ClassA
{
public:
	ClassB() { cout << "ClassB::ClassB()" << endl; }
	virtual ~ClassB() { cout << "ClassB::~ClassB()" << endl; }

	void func1() { cout << "ClassB::func1()" << endl; }
	virtual void vfunc1() { cout << "ClassB::vfunc1()" << endl; }
private:
	int bData;
};

class ClassC : public ClassB
{
public:
	ClassC() { cout << "ClassC::ClassC()" << endl; }
	virtual ~ClassC() { cout << "ClassC::~ClassC()" << endl; }

	void func2() { cout << "ClassC::func2()" << endl; }
	virtual void vfunc2() { cout << "ClassC::vfunc2()" << endl; }
private:
	int cData;
};

```

在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。 请看上面代码 (1) ClassA是基类, 有普通函数: func1() func2() 。虚函数: vfunc1() vfunc2() ~ClassA() (2) ClassB继承ClassA, 有普通函数: func1()。虚函数: vfunc1() ~ClassB() (3) ClassC继承ClassB, 有普通函数: func2()。虚函数: vfunc2() ~ClassC() 基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。
![img](https://camo.githubusercontent.com/bdddf86e57c798e673fb947ceecb0e6b37e435e76943ab3ed5b858a51e82d7fd/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138303832303136323132353438353f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c334678587a4d324d7a55354d4449792f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730)
ClassB继承与ClassA，其虚函数表是在ClassA虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的。

``` c++
ClassA *a = new ClassB();
a->func1();                    // "ClassA::func1()"   隐藏了ClassB的func1()
a->func2();                    // "ClassA::func2()"
a->vfunc1();                   // "ClassB::vfunc1()"  重写了ClassA的vfunc1()
a->vfunc2();                   // "ClassA::vfunc2()"

```
这个结果不难想象，看上图，ClassA类型的指针a能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同 这个结果已经说明了C++的隐藏、重写(覆盖)特性。

![img](https://camo.githubusercontent.com/71ce2312224e06bfd86a20b4f423705e9b26dba9eb35c5791fdff04efc00a471/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138303832313130333632383835323f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c334678587a4d324d7a55354d4449792f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730)

``` c++
ClassA* a = new ClassC;
a->func1();          // "ClassA::func1()"   隐藏ClassB::func1()
a->func2();          // "ClassA::func2()"	隐藏ClassC::func2()
a->vfunc1();	     // "ClassB::vfunc1()"	ClassB把ClassA::vfunc1()覆盖了
a->vfunc2();	     // "ClassC::vfunc2()"	ClassC把ClassA::vfunc2()覆盖了

ClassB* b = new ClassC;
b->func1();				// "ClassB::func1()"	有权限操作时，子类优先
// 可以通过 b->ClassA::func1() ，这算是派生类隐藏了基类
b->func2();				// "ClassA::func2()"	隐藏ClassC::func2()
b->vfunc1();			// "ClassB::vfunc1()"	ClassB把ClassA::vfunc1()覆盖了
b->vfunc2();			// "ClassB::vfunc2()"	ClassC把ClassA::vfunc2()覆盖了

```

#### 多继承虚函数机制
> 多继承无虚函数覆盖的情况：

``` c++
#include <iostream>
using namespace std;

class Base1
{
public:
    virtual void B1_fun1() { cout << "Base1::B1_fun1()" << endl; }
    virtual void B1_fun2() { cout << "Base1::B1_fun2()" << endl; }
    virtual void B1_fun3() { cout << "Base1::B1_fun3()" << endl; }
};
class Base2
{
public:
    virtual void B2_fun1() { cout << "Base2::B2_fun1()" << endl; }
    virtual void B2_fun2() { cout << "Base2::B2_fun2()" << endl; }
    virtual void B2_fun3() { cout << "Base2::B2_fun3()" << endl; }
};
class Base3
{
public:
    virtual void B3_fun1() { cout << "Base3::B3_fun1()" << endl; }
    virtual void B3_fun2() { cout << "Base3::B3_fun2()" << endl; }
    virtual void B3_fun3() { cout << "Base3::B3_fun3()" << endl; }
};

class Derive : public Base1, public Base2, public Base3
{
public:
    virtual void D_fun1() { cout << "Derive::D_fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};

int main(){
    Base1 *p = new Derive();
    p->B1_fun1(); // Base1::B1_fun1()
    return 0;
}
```

![img](https://camo.githubusercontent.com/1244306e6a9d98e4b71258f1bd8f091fe1ed1534cccbf0b2beb0729ce1c22a43/68747470733a2f2f7069632e6c656574636f64652d636e2e636f6d2f313631323637393837392d4442534a63652d696d6167652e706e67)

![img](https://camo.githubusercontent.com/ea7b03c2ac53a76a3177894a337448b469724fc29c43301c94e3f849d5bea40e/68747470733a2f2f7069632e6c656574636f64652d636e2e636f6d2f313631323638323133392d6f515a617a4e2d696d6167652e706e67)


> 多继承有虚函数覆盖的情况：
``` c++
#include <iostream>
using namespace std;

class Base1
{
public:
    virtual void fun1() { cout << "Base1::fun1()" << endl; }
    virtual void B1_fun2() { cout << "Base1::B1_fun2()" << endl; }
    virtual void B1_fun3() { cout << "Base1::B1_fun3()" << endl; }
};
class Base2
{
public:
    virtual void fun1() { cout << "Base2::fun1()" << endl; }
    virtual void B2_fun2() { cout << "Base2::B2_fun2()" << endl; }
    virtual void B2_fun3() { cout << "Base2::B2_fun3()" << endl; }
};
class Base3
{
public:
    virtual void fun1() { cout << "Base3::fun1()" << endl; }
    virtual void B3_fun2() { cout << "Base3::B3_fun2()" << endl; }
    virtual void B3_fun3() { cout << "Base3::B3_fun3()" << endl; }
};

class Derive : public Base1, public Base2, public Base3
{
public:
    virtual void fun1() { cout << "Derive::fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};

int main(){
    Base1 *p1 = new Derive();
    Base2 *p2 = new Derive();
    Base3 *p3 = new Derive();
    p1->fun1(); // Derive::fun1()
    p2->fun1(); // Derive::fun1()
    p3->fun1(); // Derive::fun1()
    return 0;
}
```
![img](https://camo.githubusercontent.com/53dff358ca91c64945349e3c5ba612408034b1f01053a6104f88e30b338c984b/68747470733a2f2f7069632e6c656574636f64652d636e2e636f6d2f313631323638313238392d576a446f6e492d696d6167652e706e67C)

![img](https://camo.githubusercontent.com/46f89c6d31d4d4e60abd5c648ceefee3e89ea5fd65436fa9e9cd3a9862d711e2/68747470733a2f2f7069632e6c656574636f64652d636e2e636f6d2f313631323638323139342d71684c6472692d696d6167652e706e67)
#### 纯虚函数
- 纯虚函数在类中声明时，加上 =0；
- 含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；
- 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。
抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；
- 可以声明抽象类指针，可以声明抽象类的引用；
- 子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。
- 析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。
- 在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  - 所有成员都是 public
  - 没有定义任何构造函数
  - 没有类内初始化
  - 没有基类，也没有 virtual 函数
  
#### 构造、析构要虚不
> 构造函数一般不定义为虚函数，原因：
从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。

从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。

从实现上考虑：虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。

从类型上考虑：构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。

> 析构函数一般定义成虚函数，原因：
析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

> 为什么C++默认的析构函数不是虚函数
C ++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。


#### 虚函数效率分析
虚函数的动态绑定特性虽然很好，但存在内存空间和时间开销，每个支持虚函数的类（基类或派生类）都会有一个包含其所有支持的虚函数的虚函数表的指针。每个类对象都会隐含一个虚函数表指针（virtual pointer），指向其所属类的虚函数表。当通过基类的指针或引用调用某个虚函数时，系统需要首先定位指针或引用真正对应的对象所隐含的虚函数指针，然后虚函数指针根据虚函数的名称对其所指向的虚函数表进行一个偏移定位，再调用偏移定位处的函数指针对应的虚函数，即动态绑定的解析过程。C++规范只需要编译器能够保证动态绑定的语义，但大多数编译器都采用上述方法实现虚函数。

1. 每个支持虚函数的类都有一个虚函数表，虚函数表的大小与类拥有的虚函数的多少成正比。一个程序中，每个类的虚函数表只有一个，与类对象的数量无关。支持虚函数的类的每个类对象都有一个指向类的虚函数表的虚函数指针，因此程序运行时虚函数指针引起的内存开销与生成的类对象数量成正比。
2. 支持虚函数的类生成每个对象时，在构造函数中会调用编译器在构造函数内部插入的初始化代码，来初始化其虚函数指针，使其指向正确的虚函数表。当通过指针或引用调用虚函数时，会根据虚函数指针找到相应类的虚函数表。


#### 虚函数与内联
内联函数通常可以提高代码执行速度，很多普通函数会根据情况进行内联化，但虚函数无法利用内联化的优势。

因为内联是在编译阶段编译器将调用内联函数的位置用内联函数体替代（内联展开），但虚函数本质上是运行期行为。在编译阶段，编译器无法知道某处的虚函数调用在真正执行的时候需要调用哪个具体的实现（即编译阶段无法确定其具体绑定），因此，编译阶段编译器不会对通过指针或引用调用的虚函数进行内联化。如果需要利用虚函数的动态绑定的设计优势，必须放弃内联带来的速度优势。

如果不使用虚函数，可以通过在抽象基类增加一个类型标识成员用于在运行时识别具体的派生类对象，在派生类对象构造时必须指定具体的类型。继承体系的使用者调用函数时不再需要一次间接地根据虚函数表查找虚函数指针的操作，但在调用前仍然需要使用switch语句对其类型进行识别。

因此虚函数的缺点可以认为只有两条，即虚函数表的空间开销以及无法利用内联函数的速度优势。由于每个含有虚函数的类在整个程序只有一个虚函数表，因此虚函数表引起的空间开销时非常小的。所以，可以认为虚函数引入的性能缺陷只是无法利用内联函数。 通常，非虚函数的常规设计假如需要增加一种新的派生类型，或者删除一种不再支持的派生类型，都必须修改继承体系所有使用者的所有与类型相关的函数调用代码。对于一个复杂的程序，某个继承体系的使用者会很多，每次对继承体系的派生类的修改都会波及使用者。因此，不使用虚函数的常规设计增加了代码的耦合度，模块化不强，导致项目的可扩展性、可维护性、代码可读性都会降低。面向对象编程的一个重要目的就是增加程序的可扩展性和可维护性，即当程序的业务逻辑发生改变时，对原有程序的修改非常方便，降低因为业务逻辑改变而对代码修改时出错的概率。 因此，在性能和其它特性的选择方面，需要开发人员根据实际情况进行进行权衡和取舍，如果性能检验确认性能瓶颈不是虚函数没有利用内联的优势引起，可以不必考虑虚函数对性能的影响。


#### 哪些函数不能是虚函数
> 哪些函数不能定义为虚函数？
经检验下面的几个函数都不能定义为虚函数：

1）友元函数，它不是类的成员函数

2）全局函数

3）静态成员函数，它没有this指针

4）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

> 虚函数实现机制
1、当类中存在虚函数，则编译器会在编译期自动的给该类生成一个函数表，并在所有该类的对像中放入一个隐式变量vptr,该变量是一个指针变量，它的值指向那个类中的由编译器生成的虚函数表.

2、每个类自己的虚函数入口都在这张表中维护，调用方法的时候会隐式的传入一个this指针，然后系统会根据this指针找到对应的vptr,进而找到对应的虚函数表，找到真正方法的地址，然后才去调用这个方法，这可以叫动态绑定。

3、虚函数表存放重写的虚函数，当基类的指针指向派生类的对象时，调用虚函数时都会根据vptr来选择虚函数，而基类的虚函数在派生类里已经被改写或者说已经不存在了，所以也就只能调用派生类的虚函数版本了.


### 多重继承

#### 多继承
#### 虚基类
#### 自适应偏移
#### 如何让类不能被继承

### 友元

### 返回类型协变

## 构造
### 对象构造过程
### 生成默认构造函数
### 拷贝构造函数
### 禁止类被实例化
### 禁止拷贝


## 析构
### 对象析构过程


## 内存管理
### 深拷贝和浅拷贝
### 只能在栈上或堆上生成对象
### 空类
### 简单对象



# 设计模式
## 设计模式分为三类：
- 创造型模式：单例模式、工厂模式、建造者模式、原型模式

- 结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式

- 行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式


## 下面介绍常见的几种设计模式：
- 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式
  - 简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。
  - 工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。
  - 抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。
- 观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己。
- 装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成派生类更为灵活。

